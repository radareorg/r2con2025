[INS]====Slip Compensation[caster]:(%f,%f)\n
          Caster Stop Distance: %f\n
[INS]=====Slip Compensation[pitch]:(%f,%f)\n
[INS] ====================================
[INS] ACC Slip Compensation Failure (%.1f, %.1f)\n
[INS]=====Slip Compensation[forced]:(%.1f,%.1f)\n
[INS] ACC Slip Compensation Failure -- Not Forward Motion or Not Stop!
[INS] ACC Slip Compensation Failure -- Cannot find a slip point
[INS] min_index: %d, min_value: %d, min_acc: %d\n
[INS]=====Slip Compensation[start]:(%f,%f)\n
[INS]=====Slip Compensation[normal]:(%f,%f)\n
[INS]=====Slip Compensation[turn]:(%f,%f)\n
[INS]=====Slip Compensation[IR]:(%f,%f)\n
[INS]=====Slip Compensation[stop]:(%f,%f)\n
[INS]=====Slip Compensation[bumping]:(%f,%f)\n
[INS]SCI Error!!!! --------------------
\n<<<=======================================================
[INS]--Slip Check[%d]\n
[INS]----Confirm Slip[%d]\n
[INS]----Not Slip[%d]\n
[INS]=====Slip Compensation[back]:(%f,%f)\n
[INS]=====Slip Compensation[back_caster]:(%f,%f)\n
[INS]--------Slip [%d]--%d\n
=======================================================>>>\n
----------------------------------------count: %d\n
[INS] Sensor_Check -- max_min(%5.2f, %5.2f, %5.2f) \n
[INS] Sensor_Check -- mean   (%5.2f, %5.2f, %5.2f) \n
-------------------------------------------%d\n
[INS]Acc_Z is over!! ---vb_x: %d, threshold: %d, buf_max_min:%d, buf_max:%d\n
[INS]compensating slip position ==========
[INS]Acc Bias x: %f, y: %f, z: %f\n
pch %6.1f cntF %2d lch %2d idx %3d v %7.1f w %7.1f v_c %7.1f w_c %7.1f acc_x %4d\n
pch %6.1f cntF %2d lch %2d idx %3d v %7.1f w %7.1f v_c %7.1f w_c %7.1f acc_x %4d thr %f\n
pch2 %6.1f cntF %2d cntB %2d idx %3d v %7.1f w %7.1f v_c %7.1f w_c %7.1f acc_x %4d\n
pch2 %6.1f cntF %2d cntB %2d idx %3d v %7.1f w %7.1f v_c %7.1f w_c %7.1f acc_x %4d thr %f\n
FR2 %d\t %5.2f\t %d\t %d\t %d\t %d\t %.1f\t %d\t %d\t %d\t\n
FR %d\t%f\t%d\t%d\t%f\t%f\t%d\t%d\t%f\t%d\t%d\t%d\t%d\t%d\t%d\t%d\t%d\n
#0 %d\t%d\t%d\t%d\t%d\t%d\n
#1 %d\t%d\t%d\t%d\t%d\t%d\n
#2 %d\t%d\t%d\t%d\t%d\t%d\t%4.2f\t%4.2f\n
RT %d\t%d\t%d\t%d\t%d\t%d\t%f\t%d\t%d\t%d\t%d\t%d\t%f\t%f\n
SS_STOP_SLIP_ANGLE\n
SS_STOP_SLIP_PITCH\n
SS_STOP_SLIP_PITCH_SUB\n
SS_STOP_SLIP_RIGHT_BUMPER - F\n
SS_STOP_SLIP_RIGHT_BUMPER - R\n
SS_STOP_LEFT_BUMPER - F\n
SS_STOP_LEFT_BUMPER - L\n
SS_STOP_SLIP_ACC\n
SS_STOP_SLIP_FRONT\n
SS_FORCED_SLIP\n
NONE
FRONT_ACC
FRONT_NO_ACC
FRONT_RT
FRONT_UNSTABLE
PITCH
PITCH_SUB
BACK_SLANT
BACKWARDMOTION
m_varAngEncSum = %f, degAngleEnc = %f\n
[%02d]detect error[%d, %d, %f] cur[%d, %d, %f] bef[%d, %d, %f] \n
BFind Center Offset:[%3.1f %3.1f]\n
invalid_num_cout:%d\n
vector::_M_fill_insert
vector::_M_range_check
Line ThreshCount:[%d/%d], Val:[%d]
Detect Result is Smaller than Corner Points(%d<%d)\n
ReorderCenterPoints Fail
Line Check Success
Line Check Fail
Sobel Success
Sobel Fail
[Calib: Labeling] Circle Grid Detection Failed !!!
LineNum:%d\n
Rotation center :(%f, %f)\n
Principal point :(%f, %f)\n
[Calib: Labeling] Strange Opt or Principal Value  !!!
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_17bad_function_callEEEEE
N5boost16exception_detail19error_info_injectorINS_17bad_function_callEEE
N5boost16exception_detail10clone_baseE
N5boost17bad_function_callE
N5boost9exceptionE
St13runtime_error
St9exception
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, talgo, void*>, boost::_bi::list2<boost::_bi::value<talgo*>, boost::arg<1> > >]
call to empty boost::function
(%8ld)[TALGO] %s : Waiting signal(start)\n
(%8ld)[TALGO] %s : Received signal(start)\n
(%8ld)[TALGO] %s : Entering control()\n
(%8ld)[TALGO] %s : Exiting control()\n
(%8ld)[TALGO] %s : Waiting signal(completed)\n
(%8ld)[TALGO] %s : Received signal(completed)\n
[TALGO] %s control time: %d ms. (too long! >= %d)\n
Creating %s (priority=%d)
done. (id=%s)\n
error! (%d)\n
%-12s: ctl=%-9s pwm=%+6d\n
db-motor
%-12s: reset=%d\n
mb-motor
%-12s: count=%3d mode=%3d(0x%02x) opt=%3d(0x%02x) state=%d,%d %d BlkArmRst=%d detection=(%d,%d,%d,%d) WildErr=%d MoGaCo=%d shutter=%d\n
NXP-board
%-12s: count=%3d command=%3d(0x%02x) option=%3d(0x%02x)\n
PIC-board
%-12s: ctl=%-9s pos=%+7.1f vel_max=%+6.1f\n
sb-motor
suc-motor
%-12s: ctl=%-9s vel=%+6.1f acc_max=%+6.1f\n
N5boost16bad_lexical_castE
N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_16bad_lexical_castEEEEE
St8bad_cast
N5boost16exception_detail19error_info_injectorINS_16bad_lexical_castEEE
parse
bad lexical cast: source type value could not be interpreted as target
\t\n\v\f\r
[%3d]:%-20s(%4d):%s():
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/common/command/wheel_motion_cmd.hpp
argv[%d] = %s\n
ERROR
 "%s"\n%s\n
infinity
INFINITY
%6.0f %6.0f %6.0f %6d %6d
%+6.0f %+6.0f %+6.0f %6.0f %6.0f %6.1f %+6.0f %6.0f %6.1f %6d
%+6.0f %6.0f %+6.0f %+6.0f %6.1f %6d
%+6.0f %6d %+6.0f %+6.0f %6.1f %6d
%+6.0f %6.0f %6.1f %+6.0f %+6.0f %6.0f %6.1f %6d
%+6.0f %6d %6.1f %+6.0f %+6.0f %6.0f %6.1f %6d
%+6.0f %+6.0f %+6.1f %+6.0f %6.0f %6.0f %6.1f %+6.0f %+6.0f %6.0f %6d
%+6.0f %+6.0f %6.0f %6.0f %6.1f %+6.0f %+6.0f %6.0f %6d
%+6.0f %+6.0f %+6.1f %6.0f %6.1f %+6.0f %+6.0f %6.0f %6.1f %6d
%+6.0f %+6.0f %+6.0f %+6.0f %6.0f %6.1f %+6.0f %6.1f %+6.1f %6d
%+6.0f %+6.0f %+6.1f %+6.0f %6.0f %6.0f %6.1f %+6.0f %6.1f %+6.1f %6d
%6.0f %+6.0f %6.0f %6.1f %+6.0f %6d %06X %6d %06X
%+6.0f %+6.1f %6d
%+6.6s %6d
 prof_dist req_v  req_w  req_t   fc_t
   x_t    y_t   th_t    v_c    v_t  w_max    dir    d_e   th_e  req_t
  th_t  w_max    dir  r_dir   th_e  req_t
  th_t  ctime    dir  r_dir   th_e  req_t
     l    v_c  w_max  t_dir    dir    d_e   th_e  req_t
     l  ctime  w_max  t_dir    dir    d_e   th_e  req_t
   x_l    y_l   th_l    l_l    v_c    v_t  w_max    dir  r_dir    d_e  req_t
   x_t    y_t    v_c    v_t  w_max    dir  r_dir    d_e  req_t
   x_t    y_t   th_t    v_t  w_max    dir  r_dir    d_e   th_e  req_t
   x_c    y_c      r    d_l    v_t  w_max    dir    l_e     th   fc_t
   x_l    y_l   th_l    d_l    v_c    v_t  w_max    dir    l_e      d   fc_t
     l  w_dir    v_t  w_max    dir   mode  smask    sid sbitset
     v      w   fc_t
   ctl  mc_t
stop [prof_dist req_v_e req_w_e req_t [fc_time]]
move-pose x_t y_t th_t [v_c [v_t w_max dir [req_d_e req_th_e req_t]]]
rotate th_t [w_max [dir r_dir [req_th_e req_t]]]
timed-rotate th_t ctime [dir r_dir [req_th_e req_t]]
move-fw l [v_c [w_max dir [req_d_e req_th_e req_t]]]
timed-move-fw l ctime [w_max dir [req_d_e req_th_e req_t]]
move-bw l [v_c [w_max dir [req_d_e req_th_e req_t]]]
timed-move-bw l ctime [w_max dir [req_d_e req_th_e req_t]]
reach-line x_l y_l th_l [l_l [v_c [v_t w_max dir r_dir [req_d_e req_t]]]]
move-to x_t y_t [v_c [v_t w_max dir r_dir [req_d_e req_t]]]
turn-to x_t y_t th_t [v_t w_max dir r_dir [req_d_e req_th_e req_t]]
follow-circle x_c y_c r [d_l [v_t [w_max dir [req_l_e req_th fc_time]]]]
follow-line x_l y_l th_l [d_l [v_c v_t [w_max dir [req_l_e req_d fc_time]]]]
follow-wall l w_dir [v_t [w_max dir [mode smask sid sbitset]]]
ctl-speed v [w [fc_time]]
ctl-motor on|off|clr [mc_t]
approach_obs l w_dir [v_t [w_max dir [mode smask sid sbitset]]]
none
move-pose
timed-rotate
move-fw
timed-move-fw
move-bw
timed-move-bw
reach-line
move-to
turn-to
follow-circle
follow-line
follow-wall
ctl-speed
ctl-motor
approach_obs
%-12s: ctl=%-9s v=%+6.1f w=%+6.1f Kp=%3d Ki=%3d Kd=%3d Kff=%3d Kdz=%3d\n
wheel-motor
wheel-motion
wheel_motion_cmd report:\n
/etc/bsp_version
-%10d
/tmp/update_success
/tmp/update_fail
/proc/stat
cpu %Ld %Ld %Ld %Ld
Fail to fscanf()\n
/proc/cpuinfo
processor
~param_elem_base
~param_elem
~param_elem
~param_elem
~param_elem
~param_elem
~param_elem
~param_elem
~param_elem
~param_elem
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = bool (*)(const std::basic_string<char>&, bool&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void (*)(const msgout*, const std::basic_string<char>&, bool)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = bool (*)(const std::basic_string<char>&, int&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void (*)(const msgout*, const std::basic_string<char>&, int)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = bool (*)(const std::basic_string<char>&, float&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void (*)(const msgout*, const std::basic_string<char>&, float)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = bool (*)(const std::basic_string<char>&, std::basic_string<char>&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void (*)(const msgout*, const std::basic_string<char>&, const std::basic_string<char>&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = bool (*)(const std::basic_string<char>&, std::vector<bool>&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void (*)(const msgout*, const std::basic_string<char>&, const std::vector<bool>&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = bool (*)(const std::basic_string<char>&, std::vector<int>&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void (*)(const msgout*, const std::basic_string<char>&, const std::vector<int>&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = bool (*)(const std::basic_string<char>&, std::vector<float>&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void (*)(const msgout*, const std::basic_string<char>&, const std::vector<float>&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = bool (*)(const std::basic_string<char>&, std::vector<std::basic_string<char> >&)]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void (*)(const msgout*, const std::basic_string<char>&, const std::vector<std::basic_string<char> >&)]
basic_string::_S_construct null not valid
disable
  %-57.57s = %d\n
  %-57.57s = %f\n
  %-57.57s = %s\n
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/common/config/param.cpp
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/common/config/param.hpp
%s = %s\n
  Invalid value (can't convert): %s = %s\n
Parameter report: (%d parameters)\n
done. (%d parameters
 printed in %.3f ms)\n
  (%4d) %-30s: "%s"\n
Duplicated param
Invalid value (can't convert)
  (%4d) %-57.57s = %s\n
False param
Invalid format(value)
Invalid format(variable)
  Not updated param:
(convert using default value)
    [%4d] %s = %s\n
      Invalid value (can't convert)
None
  Not converted param:
(invalid value format)
  Result:  Expected=%d, Not updated=%d, Not converted=%d\n
  %-50.50s [%4d] = %s\n
vector<bool>::_M_insert_aux
uatlas.model_name
VR7000M-Tizen
uatlas.console
uatlas.countout
uatlas.start_mode
stdoutlevel.begin
stdoutlevel.end
dbgoutlevel.begin
dbgoutlevel.end
sysoutlevel.begin
sysoutlevel.end
msgoutlevel.begin
msgoutlevel.end
console.thread.priority
console.std.input
console.std.output
console.serial.input
console.serial.output
console.serial.port
/dev/ttyS0
console.serial.baudrate
115200
console.serial.recv_min_size
console.serial.recv_timeout
console.serial.thread.priority
console.socket.input
console.socket.output
console.socket.port
30000
console.socket.thread.priority
device.thread
device.thread.auto_start
device.thread.priority
device.thread.sampling_time
device.thread.time_report
device.pibo
device.pibo.thread
device.pibo.thread.priority
device.pibo.thread.time_report
device.pibo.serial.port
/dev/ttySAC1
device.pibo.serial.baudrate
device.pibo.serial.recv_min_size
device.pibo.serial.recv_timeout
device.pibo.serial.thread.priority
device.pibo.pkt_ser.recv_mode
CALLBACK
device.pibo.pkt_ser.recv_timeout
device.pibo.pkt_ser.chksum
device.pibo.pkt_ser.verbose
device.pibo.pkt_ser.time_report
device.pibo.pkt_ser.time_print
device.pibo.pkt_ser.stat_report
device.pibo.pkt_ser.log
device.pibo.rcvpkt.report
device.pibo.rcvpkt.time_check
device.pibo.rcvpkt.time_print
device.pibo.sndpkt.report
device.nxbo
device.nxbo.thread
device.nxbo.thread.priority
device.nxbo.thread.time_report
device.nxbo.serial.port
/dev/ttyS6
device.nxbo.serial.baudrate
device.nxbo.serial.recv_min_size
device.nxbo.serial.recv_timeout
device.nxbo.serial.thread.priority
device.nxbo.pkt_ser.recv_mode
device.nxbo.pkt_ser.recv_timeout
device.nxbo.pkt_ser.chksum
device.nxbo.pkt_ser.verbose
device.nxbo.pkt_ser.time_report
device.nxbo.pkt_ser.time_print
device.nxbo.pkt_ser.stat_report
device.nxbo.pkt_ser.log
device.nxbo.pkt_ser.print_chksum_mismatch
device.nxbo.rcvpkt.report
device.nxbo.rcvpkt.time_print
device.nxbo.rcvpkt.time_check
device.nxbo.sndpkt.report
device.res.board.thread
device.res.board.thread.priority
device.res.board.thread.wait_start_signal
device.res.board.thread.sampling_time
device.res.board.thread.time_report
device.res.motor.thread
device.res.motor.thread.priority
device.res.motor.thread.wait_start_signal
device.res.motor.thread.sampling_time
device.res.motor.thread.time_report
device.res.sensor.thread
device.res.sensor.thread.priority
device.res.sensor.thread.wait_start_signal
device.res.sensor.thread.sampling_time
device.res.sensor.thread.time_report
device.res.sensor.ol_processing
device.res.sensor.ol_processing.thread.priority
device.res.sensor.ol_processing.thread.wait_start_signal
device.res.sensor.ol_processing.thread.sampling_time
device.res.sensor.ol_processing.thread.sleep_time
device.res.sensor.ol_processing.thread.time_report
device.res.sensor.ol_processing.thread.control_max_time
device.res.sensor.acc_manager
device.res.sensor.acc_manager.sample_rate
device.res.sensor.acc_manager.sense_range
device.res.sensor.acc_manager.thread.priority
device.res.sensor.acc_manager.thread.wait_start_signal
device.res.sensor.acc_manager.thread.sampling_time
1000
device.res.sensor.acc_manager.thread.time_report
device.res.ui.thread
device.res.ui.thread.priority
device.res.ui.thread.wait_start_signal
device.res.ui.thread.sampling_time
device.res.ui.thread.time_report
status.thread
status.thread.auto_start
status.thread.priority
status.thread.sampling_time
status.thread.time_report
status.log
status.log.size
status.log.rate
status.log.use_copy
status.log.filename
status.log.filename.use_scriptname
status.log.print_wheel
status.log_sig
status.log_sig.size
status.log_sig.rate
status.log_sig.use_copy
status.log_sig.filename
signal.log
status.log_sig.filename.use_scriptname
status.map_building
status.map_building.time_report
status.map_building.pose
status.map_building.obstacle_count_threshold
status.map_building.ir.install_r
214.4 256.4 237.6 216.4 201.2 193.0 193.0 201.2 216.5 237.6 256.4 214.4
status.map_building.ir.install_th
+40.93 +42.34 +36.09 +27.51 +17.35 +5.95 -5.94 -17.35 -27.51 -36.1 -41.52 -40.93
status.map_building.ir.install_q
+50 0 0 0 0 0 0 0 0 0 0 -50
status.map_building.ir.mapping_min_dist
0 0 0 0 0 0 0 0 0 0 0 0
status.map_building.ir.mapping_max_dist
80 90 100 100 100 100 100 100 100 100 90 80
status.map_building.ir.mapping_inc_count
1 1 1 1 1 1 1 1 1 1 1 1
status.map_building.bott.install_r
197.5 197.5 197.5
status.map_building.bott.install_th
+65 -65 0
status.map_building.bump.install_r
220.0 220.0 240.0 240.0
status.map_building.bump.install_th
+20.0 -20.0 +55.0 -55.0
status.map_building.upp_dist.install_r
220.0 220.0 171.0
status.map_building.upp_dist.install_th
0.0 0.0 0
status.map_building.upp_dist.install_q
0 0 0
status.map_building.monitoring.socket
status.map_building.monitoring.socket.port
20007
status.map_building.monitoring.socket.thread.priority
status.map_building.monitoring.sleep_time
status.map_building.monitoring.console_log
status.map_building.monitoring.local_map
status.map_building.monitoring.navigation
status.map_building.monitoring.navigation.full_frame
status.map_building.monitoring.sensor
status.map_building.monitoring.sensor.full_frame
status.map_building.monitoring.board
status.map_building.monitoring.board.full_frame
status.map_building.monitoring.virtual_sensor
status.map_building.monitoring.virtual_gate
status.map_building.thread
status.map_building.thread.priority
status.map_building.thread.wait_start_signal
status.map_building.thread.sampling_time
status.map_building.thread.sleep_time
status.map_building.thread.time_report
status.map_building.thread.control_max_time
status.map_building.rec_in_robot.rec_in_robot_flag
status.map_building.rec_in_robot.rec_min_size
3000
status.map_building.rec_in_robot.rec_path_name
/mnt/mmc/debug/
status.map_building.rec_in_robot.rec_fsys_name
/opt/storage/sdcard
status.map_building.history_pos.save_trajectory
status.localization
status.localization.time_report
status.localization.rotation_check_method
status.localization.use_cam_param_devel
status.localization.gyro
status.localization.gyro.check_index
status.localization.gyro.max_diff
status.localization.thread
status.localization.thread.priority
status.localization.thread.wait_start_signal
status.localization.thread.sampling_time
status.localization.thread.sleep_time
status.localization.thread.time_report
status.localization.thread.control_max_time
status.slip_compensation
status.slip_compensation.time_report
status.slip_compensation.msglevel
status.slip_compensation.slip_acc
status.slip_compensation.slip_front
status.slip_compensation.slip_front_rt
status.slip_compensation.slip_unstable
status.slip_compensation.slip_rt
status.slip_compensation.slip_err
status.slip_compensation.slip_slant
status.slip_compensation.slip_slant_sub
status.slip_compensation.slip_back_slant
status.slip_compensation.slip_climb_with_gyro
status.slip_compensation.slip_back_climb_with_gyro
status.slip_compensation.slip_backward
status.slip_compensation.use_ignore_bump_mask
status.slip_compensation.slip_slant_thr
-2.0
status.slip_compensation.slip_slant_sub_thr
-1.5
status.slip_compensation.slip_back_slant_thr
status.slip_compensation.slip_climb_with_gyro_thr
status.slip_compensation.slip_back_climb_with_gyro_thr
status.slip_compensation.slip_unstable_short_thr
status.slip_compensation.slip_unstable_forward_thr
status.slip_compensation.slip_unstable_long_thr
status.slip_compensation.slip_front_thr
status.dead_reckoning.method
status.dead_reckoning.time_report
status.velocity_measurement
status.velocity_measurement.time_report
status.velocity_measurement.method
status.sensor_modification
status.sensor_modification.time_report
status.sensor_modification.msglevel.docking_candidate
status.sensor_modification.msglevel.docking_signal
status.sensor_modification.msglevel.mod_acc
status.sensor_modification.virtual_halo
status.sensor_modification.virtual_halo.station_size.regular
status.sensor_modification.virtual_halo.station_size.auto
status.sensor_modification.virtual_halo.station_size.small
status.sensor_modification.virtual_halo.station_holding.time_count
status.sensor_modification.virtual_halo.station_holding.bump_count
status.sensor_modification.virtual_gate
status.sensor_modification.virtual_magnetic_gate
status.sensor_modification.virtual_magnetic_gate.moving_ext_cell
status.sensor_modification.virtual_magnetic_gate.cleaning_ext_cell
status.sensor_modification.ir_modification
status.sensor_modification.upper_stuck_threshold.left
status.sensor_modification.upper_stuck_threshold.front
status.sensor_modification.upper_stuck_threshold.right
status.sensor_modification.upper_stuck_threshold.max_count
status.sensor_modification.upper_stuck_threshold.latch_max_count
status.sensor_modification.upper_dist_offset_l
status.sensor_modification.upper_dist_offset_f
status.sensor_modification.upper_dist_offset_r
status.sensor_modification.upper_stuck_new
status.sensor_modification.narrow_pass
status.sensor_modification.narrow_pass.dist_sum
status.sensor_modification.narrow_pass.threshold
0 0 0 200 200 200 200 200 200 0 0 0
status.sensor_modification.narrow_pass.ir_min
status.sensor_modification.ignore.ir
status.sensor_modification.ignore.bott
status.sensor_modification.ignore.bump
status.sensor_modification.ignore.susp
status.sensor_modification.ignore.etc
status.sensor_modification.ignore.upp_dist
status.sensor_modification.virtual_rear
status.sensor_modification.sensor_array.dist_near_thres
status.sensor_modification.sensor_array.sarray_update_period
status.sensor_modification.back_slant_with_lift
status.sensor_modification.dock_sig_latch_max
status.sensor_modification.wild_deep
status.sensor_modification.accepted_obs_cnt
0 0 0 2 2 2 2 2 2 0 0 0
status.sensor_modification.ignore_ol_diff
status.sensor_modification.rotate_halo
status.sensor_modification.rotate_halo.ang_low
status.sensor_modification.rotate_halo.ang_high
status.sensor_modification.rotate_halo.near_cell_dist
status.sensor_modification.rotate_side_halo
status.sensor_modification.rotate_side_halo.ang_low
status.sensor_modification.rotate_side_halo.ang_high
status.sensor_modification.rotate_side_halo.near_cell_dist
status.sensor_modification.homing__with_map
status.sensor_modification.homing_area_cleaning__with_map
status.sensor_modification.charger_front_angle_compensation
status.hwevent_processing
status.hwevent_processing.time_report
status.hwevent_processing.block_reset_arm
status.hwevent_processing.safe_exit_block_reset_arm
status.sound_play
status.sound_play.aui_path
/usr/apps/rvc/aui/
status.sound_play.dev_name
default
status.sound_play.sound_vol
status.sound_play.print_sound_id
status.sound_play.thread.priority
status.sound_play.thread.wait_start_signal
status.sound_play.thread.sampling_time
status.sound_play.thread.sleep_time
status.sound_play.thread.time_report
status.sound_play.thread.control_max_time
status.report
status.report.time_report
status.report.socket.port
31000
status.report.socket.thread.priority
status.report.thread
status.report.thread.priority
status.report.thread.wait_start_signal
status.report.thread.sampling_time
status.report.thread.sleep_time
status.report.thread.time_report
status.report.thread.control_max_time
status.wild.tbl_path
/usr/apps/rvc/
status.wild.use_eeprom
status.wild.use_viewer
status.wild.msglevel.disp_grab
status.wild.msglevel.disp_callback
status.wild.process.center_x
status.wild.process.center_y
status.wild.process.center_rotation
status.wild.process.y_rate_up
status.wild.process.y_rate_dn
status.wild.process.x_rate_left
status.wild.process.x_rate_right
status.wild.process.radius_max
status.wild.process.radius_min
status.wild.process.jump_pixel
status.wild.process.size_filter
status.wild.process.diff_image
status.wild.process.deg_of_sensor
status.wild.process.sen_angle_max
status.wild.process.sen_angle_min
status.wild.process.th_near
status.wild.process.th_far
status.wild.process.pixel_min
status.wild.process.twin_max_range
status.wild.process.twin_center_x
status.wild.process.twin_center_y
status.wild.process.variable_ratio
status.wild.process.sun_th
status.wild.wf.intensity_min_threshold
status.wild.wf.diff_threshold
status.wild.wf.min_size
status.wild.wf.radius_min
status.wild.wf.radius_max
status.wild.wf.theta_min
status.wild.wf.theta_max
status.wild.wf.dist_100mm_pt
87 87
status.wild.wf.pixel_to_dist_ratio
status.wild.wf.variable_ratio
status.wild_sub.tbl_path
status.wild_sub.use_eeprom
status.wild_sub.center_x
160.0
status.wild_sub.center_y
145.0
status.wild_sub.rotation
status.wild_sub.front.near_th
status.wild_sub.front.far_th
status.wild_sub.front.angle_min
status.wild_sub.front.angle_max
status.wild_sub.front.mask_lower.diff0_x
status.wild_sub.front.mask_lower.diff0_y
55.0
status.wild_sub.front.mask_lower.diff1_x
35.0
status.wild_sub.front.mask_lower.diff1_y
50.0
status.wild_sub.front.small_circular.diff_x
status.wild_sub.front.small_circular.diff_y
20.0
status.wild_sub.front.small_circular.range
170.0
status.wild_sub.front.big_circular.diff_x
status.wild_sub.front.big_circular.diff_y
165.0
status.wild_sub.front.big_circular.range
290.0
status.wild_sub.side.threshold
status.wild_sub.side.angle_start
status.wild_sub.side.angle_limit
status.wild_sub.side.lower_limit
status.wild_sub.side.upper_limit
status.wild_sub.side.dist_100mm_pt
40 40
status.wild_sub.side.pixel_to_dist_ratio
status.cam_control
status.cam_control.ceiling_cam_off
status.cam_control.wild_cam_off
task.thread
task.thread.priority
task.thread.sampling_time
task.thread.time_report
task.nav.time_report
task.nav.tmb_max_time
task.nav.fsm_max_time
task.nav.tmb_sub_time_report
task.nav.tmb_sub_max_time
task.nav.thread.priority
task.nav.thread.wait_start_signal
task.nav.thread.sampling_time
task.nav.thread.sleep_time
task.nav.thread.time_report
task.nav.thread.control_max_time
task.nav.path_planning.via_max_safe_radius
task.nav.path_planning.via_base_safe_radius
task.nav.path_planning.via_safe_radius_margin
task.nav.path_planning.via_safe_radius_vanish_angle_deg
task.nav.path_planning.via_safe_radius_vanish_length_mm
task.nav.path_planning.via_safe_radius_kv
task.nav.path_planning.via_min_vel
task.nav.path_planning.via_merge_cell_num
task.nav.path_planning.msglevel.disp_general
task.nav.path_planning.msglevel.disp_data
task.nav.path_planning.msglevel.disp_time
task.nav.path_planning.goal_re_search.mode
task.nav.path_planning.goal_re_search.mode_near.one_dir_search_dist_thres
task.nav.path_planning.goal_re_search.max_goal_re_search_count
task.nav.path_planning.goal_re_search.one_dir_search_cnt_thres
task.nav.path_planning.goal_re_search.search_dir_num
task.nav.path_planning.goal_re_search.g_re_search_msg_out_level
task.nav.path_planning.min_goal_cell_width
task.nav.path_planning.cell_extend
task.nav.path_planning.cell_diff
task.nav.path_planning.path_length_margin
task.nav.auto_planning.mode
task.nav.auto_planning.time_report
task.nav.auto_planning.smooth_turn
task.nav.auto_planning.smooth_turn.large_sector
task.nav.auto_planning.followwall
task.nav.auto_planning.divide_district
task.nav.auto_planning.mod_bott_action
task.nav.auto_planning.fw_timeout
20000
task.nav.auto_planning.fw_timeout_step
task.nav.auto_planning.max_dist_cell_use_undercell
task.nav.auto_planning.dist_cell_door
task.nav.auto_planning.need_restart_time_elapse
task.nav.auto_planning.restart_limit_time_elapse
task.nav.auto_planning.first_clean_around_station
task.nav.auto_planning.approach_fw_mode
task.nav.auto_planning.save_map
task.nav.auto_planning.save_first_zigzag_map_in_auto_cleaning
task.nav.auto_planning.first_moving__area_cleaning
task.nav.auto_planning.first_moving_dist__area_cleaning
2000
task.nav.auto_planning.magnetic_gate__area_cleaning
task.nav.auto_planning.save_history_map
task.nav.auto_planning.infinite_cleaning
task.nav.auto_planning.allow_double_zigzag
task.nav.auto_planning.use_slam_map_save
task.nav.auto_planning.use_slam_map_load
task.nav.auto_planning.use_escape_wf
task.nav.auto_planning.msglevel.disp_general
task.nav.auto_planning.msglevel.disp_state
task.nav.auto_planning.msglevel.disp_aligner
task.nav.auto_planning.msglevel.disp_sector_clean
task.nav.auto_planning.msglevel.disp_smooth_turn
task.nav.auto_planning.msglevel.disp_followwall
task.nav.auto_planning.msglevel.disp_divide_district
task.nav.auto_planning.thread
task.nav.auto_planning.thread.priority
task.nav.auto_planning.thread.wait_start_signal
task.nav.auto_planning.thread.wait_completed_signal
task.nav.auto_planning.thread.sampling_time
task.nav.auto_planning.thread.sleep_time
task.nav.auto_planning.thread.time_report
task.nav.auto_planning.thread.control_max_time
task.nav.auto_planning.thread.msglevel.disp_sync
task.nav.goto_planning.mode
task.nav.goto_planning.time_report
task.nav.goto_planning.msglevel.disp_general
task.nav.goto_planning.thread
task.nav.goto_planning.thread.priority
task.nav.goto_planning.thread.wait_start_signal
task.nav.goto_planning.thread.wait_completed_signal
task.nav.goto_planning.thread.sampling_time
task.nav.goto_planning.thread.sleep_time
task.nav.goto_planning.thread.time_report
task.nav.goto_planning.thread.control_max_time
task.nav.goto_planning.thread.msglevel.disp_sync
task.nav.fsm.auto_planning_start_mode
task.nav.fsm.reset_log_before_auto_planning
task.nav.fsm.write_log_after_auto_planning
task.nav.fsm.parse_in_entry
task.nav.fsm.obstacle_slowdown_factor
0.36666
task.nav.fsm.obstacle_slowdown_time
task.nav.fsm.obstacle_approach_obs_factor
task.nav.fsm.gyro_reset.req_angle
0.01
task.nav.fsm.gyro_reset.req_count
task.nav.fsm.gyro_reset.max_count
task.nav.fsm.gyro_stop.on_roundturn
task.nav.fsm.gyro_stop.interval
10000
task.nav.fsm.gyro_stop.duration
task.nav.fsm.manual.lin_vel
task.nav.fsm.manual.ang_vel
task.nav.fsm.manual.back_lin_vel
task.nav.fsm.manual.stop_delay
task.nav.fsm.manual.wild_cam_off
task.nav.fsm.spot.followcircle.v_t
task.nav.fsm.spot.followcircle.th_d
task.nav.fsm.ignore.bump
task.nav.fsm.ignore.slip
task.nav.fsm.ignore.ir
task.nav.fsm.ignore.upp_dist
task.nav.fsm.ir.long_threshold
80 130 130 130 130 130 130 130 130 130 130 80
task.nav.fsm.ir.short_threshold
60 90 100 100 100 100 100 100 100 100 90 60
task.nav.fsm.ir.long_threshold.max_count
task.nav.fsm.ir.short_threshold.max_count
task.nav.fsm.ir.emc_turn_threshold
0 0 30 48 58 62 62 58 48 30 0 0
task.nav.fsm.ir.emc_turn_threshold.max_count
task.nav.fsm.ir.emc_stop_threshold
0 60 60 60 60 60 60 60 60 60 60 0
task.nav.fsm.ir.emc_stop_threshold.max_count
task.nav.fsm.ir_drag.pf.np
task.nav.fsm.ir_drag.pf.thresh_neff
task.nav.fsm.ir_drag.pf.reset_neff
task.nav.fsm.ir_drag.pf.var_predict
29.0
task.nav.fsm.ir_drag.pf.var_measure
23.0
task.nav.fsm.ir_drag.pf.thresh_no_input
task.nav.fsm.ir_drag.pf.thresh_sensor_inputs
task.nav.fsm.ir_drag.motion.front_boundary_angle
task.nav.fsm.ir_drag.motion.rot_init_angle
90.0
task.nav.fsm.ir_drag.motion.rot_vel_time_constant
10.0
task.nav.fsm.ir_drag.motion.variation_angle
task.nav.fsm.ir_drag.motion.max_trans_vel
320.0
task.nav.fsm.ir_drag.motion.max_rot_vel
100.0
task.nav.fsm.ir_drag.print_log
task.nav.fsm.docking.print_log
task.nav.fsm.docking.msglevel_mode
task.nav.fsm.docking.msglevel_general
task.nav.fsm.docking.msglevel_debug_docking
task.nav.fsm.docking.msglevel_debug_seeking
task.nav.fsm.msglevel.general
task.nav.fsm.msglevel.state
task.nav.fsm.msglevel.action
task.nav.fsm.msglevel.motion
task.nav.fsm.msglevel.input_result
task.nav.fsm.find_ceiling_angle
task.nav.fsm.find_ceiling_angle.cnt
task.nav.fsm.find_ceiling_angle.err
task.nav.fsm.find_ceiling_angle.accuracy
task.nav.fsm.find_ceiling_angle.dist_min
task.nav.fsm.relocation.slam_pause_point
task.nav.fsm.relocation.max_retry
task.nav.fsm.relocation.min_total_lm
task.nav.fsm.relocation.initial_wait_time
task.nav.fsm.relocation.localize_wait_time
task.nav.fsm.relocation.erase_map
task.nav.fsm.relocation.erase_map.ext
task.nav.fsm.relocation.erase_map.except_cliff
task.nav.fsm.relocation.erase_map.except_lift
task.nav.fsm.relocation.erase_map.except_danger
task.nav.fsm.relocation.revert_map
task.nav.fsm.relocation.modify_map
task.nav.fsm.relocation.modify_map.cliff_ext
task.nav.fsm.relocation.modify_map.danger_ext
task.nav.fsm.relocation.return_to
task.nav.fsm.relocation.return_to.offset
task.nav.fsm.relocation.return_to.wait_time_on
task.nav.fsm.motion.v_c
task.nav.fsm.motion.w_max
task.nav.fsm.motion.followcircle.v_t
task.nav.fsm.motion.followcircle.th_d
task.nav.fsm.motion.followcircle.lat_acc
21000
task.nav.fsm.motion.followwall.l
task.nav.fsm.motion.followwall.v_t
task.nav.fsm.motion.followwall.w_max
task.nav.fsm.motion.force_reach_line
task.nav.fsm.motion.force_follow_line
task.nav.fsm.motion.segment_len
task.nav.fsm.motion.followcircle_roundturn
task.nav.fsm.motion.followline_roundturn_begin
task.nav.fsm.motion.followline_roundturn_end
task.nav.fsm.motion.odometry_roundturn
task.nav.fsm.motion.forced_rotate_dir
task.nav.fsm.motion.forced_rotate_dir.min_angle_error
task.nav.fsm.motion.forced_rotate_dir.min_gyro_angle_sum
task.nav.fsm.action.none.timeout
task.nav.fsm.action.ctl_motor.timeout
task.nav.fsm.action.stop.timeout
task.nav.fsm.action.moveto.timeout
task.nav.fsm.action.rotate.timeout
task.nav.fsm.action.rotate.backward_timeout
4000
task.nav.fsm.action.rotate.forced_time
task.nav.fsm.action.followcircle.timeout
5000
task.nav.fsm.action.followcircle.pure_interval
task.nav.fsm.action.followline.timeout
40000
task.nav.fsm.action.followline.pure_interval
task.nav.fsm.action.followwall.pure_interval
task.nav.fsm.action.sensor_stop.timeout
task.nav.fsm.action.sensor_stopandcheck.timeout
task.nav.fsm.action.sensor_stopandcheck.check_time
task.nav.fsm.action.sensor_back.timeout
task.nav.fsm.action.sensor_stopandback.timeout
task.nav.fsm.action.sensor_approach_obs.timeout
task.nav.fsm.action.sensor_approach_obs.check_time
task.nav.fsm.action.sensor_stopandcheckandback.timeout
task.nav.fsm.action.sensor_stopandcheckandback.check_time
task.nav.fsm.sensor_action.ir
task.nav.fsm.sensor_action.bott
task.nav.fsm.sensor_action.bump
task.nav.fsm.sensor_action.magnet
task.nav.fsm.sensor_action.sg_gate
task.nav.fsm.sensor_action.sg_fence
task.nav.fsm.sensor_action.mb_tangle
task.nav.fsm.sensor_action.sb_tangle
task.nav.fsm.sensor_action.lift
task.nav.fsm.sensor_action.wstuck
task.nav.fsm.sensor_action.climb
task.nav.fsm.sensor_action.slip
task.nav.fsm.sensor_action.st_fence
task.nav.fsm.sensor_action.emc_turn
task.nav.fsm.sensor_action.narrow_pass
task.nav.fsm.sensor_action.emc_stop
task.nav.fsm.sensor_action.upper_stuck
task.nav.fsm.sensor_action.back_climb
task.nav.fsm.sensor_action.ir.back_dist
task.nav.fsm.sensor_action.bott.back_dist
task.nav.fsm.sensor_action.bump.back_dist
task.nav.fsm.sensor_action.magnet.back_dist
task.nav.fsm.sensor_action.sg_gate.back_dist
task.nav.fsm.sensor_action.sg_fence.back_dist
task.nav.fsm.sensor_action.mb_tangle.back_dist
task.nav.fsm.sensor_action.sb_tangle.back_dist
task.nav.fsm.sensor_action.lift.back_dist
task.nav.fsm.sensor_action.wstuck.back_dist
task.nav.fsm.sensor_action.climb.back_dist
task.nav.fsm.sensor_action.slip.back_dist
task.nav.fsm.sensor_action.st_fence.back_dist
task.nav.fsm.sensor_action.emc_turn.back_dist
task.nav.fsm.sensor_action.narrow_pass.back_dist
task.nav.fsm.sensor_action.emc_stop.back_dist
task.nav.fsm.sensor_action.upper_stuck.back_dist
task.nav.fsm.sensor_action.back_climb.back_dist
task.nav.fsm.sensor_action.ir.back_vel
task.nav.fsm.sensor_action.bott.back_vel
task.nav.fsm.sensor_action.bump.back_vel
task.nav.fsm.sensor_action.magnet.back_vel
task.nav.fsm.sensor_action.sg_gate.back_vel
task.nav.fsm.sensor_action.sg_fence.back_vel
task.nav.fsm.sensor_action.mb_tangle.back_vel
task.nav.fsm.sensor_action.sb_tangle.back_vel
task.nav.fsm.sensor_action.lift.back_vel
task.nav.fsm.sensor_action.wstuck.back_vel
task.nav.fsm.sensor_action.climb.back_vel
task.nav.fsm.sensor_action.slip.back_vel
task.nav.fsm.sensor_action.st_fence.back_vel
task.nav.fsm.sensor_action.emc_turn.back_vel
task.nav.fsm.sensor_action.narrow_pass.back_vel
task.nav.fsm.sensor_action.emc_stop.back_vel
task.nav.fsm.sensor_action.upper_stuck.back_vel
task.nav.fsm.sensor_action.back_climb.back_vel
task.nav.fsm.sensor_action.ir.dynamics
task.nav.fsm.sensor_action.bott.dynamics
task.nav.fsm.sensor_action.bump.dynamics
task.nav.fsm.sensor_action.magnet.dynamics
task.nav.fsm.sensor_action.sg_gate.dynamics
task.nav.fsm.sensor_action.sg_fence.dynamics
task.nav.fsm.sensor_action.mb_tangle.dynamics
task.nav.fsm.sensor_action.sb_tangle.dynamics
task.nav.fsm.sensor_action.lift.dynamics
task.nav.fsm.sensor_action.wstuck.dynamics
task.nav.fsm.sensor_action.climb.dynamics
task.nav.fsm.sensor_action.slip.dynamics
task.nav.fsm.sensor_action.st_fence.dynamics
task.nav.fsm.sensor_action.emc_turn.dynamics
task.nav.fsm.sensor_action.narrow_pass.dynamics
task.nav.fsm.sensor_action.emc_stop.dynamics
task.nav.fsm.sensor_action.upper_stuck.dynamics
task.nav.fsm.sensor_action.back_climb.dynamics
task.nav.fsm.sensor_action.emc_turn_decision.wf_sensor_emc_turn_thres
task.view.callback
task.view.callback_rm
task.view.rm_adv
task.view.time_report
task.view.socket.domain
INET
task.view.socket.port
20008
task.view.socket.path
/tmp/ipc_uds_view
task.view.socket.thread.priority
task.view.thread
task.view.thread.priority
task.view.thread.wait_start_signal
task.view.thread.sampling_time
task.view.thread.sleep_time
task.view.thread.time_report
task.view.thread.control_max_time
mobility.pose
mobility.use_gyro_ang_diff
mobility.thread
mobility.thread.auto_start
mobility.thread.priority
mobility.thread.sampling_time
mobility.thread.time_report
mobility.wheel_motor.use_micom_param
mobility.wheel_motor.encoder.ppr
mobility.wheel_motor.encoder.freq_mul
mobility.wheel_motor.gear_ratio
63.6
mobility.wheel_motor.wheel_radius
40.0
mobility.wheel_motor.wheel_base
262.7
mobility.wheel_motor.gain.k_p
mobility.wheel_motor.gain.k_i
mobility.wheel_motor.gain.k_d
mobility.wheel_motor.gain.k_ff
mobility.wheel_motor.gain.k_dz
mobility.wheel_motion.dynamics.acc_limit_in_followwall
mobility.wheel_motion.dynamics.max_lin_vel
mobility.wheel_motion.dynamics.max_ang_vel
mobility.wheel_motion.dynamics.max_lat_acc
9000
mobility.wheel_motion.dynamics.max_lin_acc
mobility.wheel_motion.dynamics.max_lin_dcc
mobility.wheel_motion.dynamics.max_ang_acc
mobility.wheel_motion.dynamics.max_ang_dcc
mobility.wheel_motion.dynamics.max_wheel_vel
mobility.wheel_motion.dynamics.wf_max_lin_vel
mobility.wheel_motion.dynamics.wf_max_ang_vel
mobility.wheel_motion.dynamics.wf_max_lat_acc
mobility.wheel_motion.dynamics.wf_max_lin_acc
mobility.wheel_motion.dynamics.wf_max_lin_dcc
mobility.wheel_motion.dynamics.wf_max_ang_acc
mobility.wheel_motion.dynamics.wf_max_ang_dcc
mobility.wheel_motion.dynamics.wf_max_wheel_vel
mobility.wheel_motion.dynamics.wf_c_max_lin_vel
mobility.wheel_motion.dynamics.wf_c_max_ang_vel
mobility.wheel_motion.dynamics.wf_c_max_lat_acc
mobility.wheel_motion.dynamics.wf_c_max_lin_acc
mobility.wheel_motion.dynamics.wf_c_max_lin_dcc
mobility.wheel_motion.dynamics.wf_c_max_ang_acc
mobility.wheel_motion.dynamics.wf_c_max_ang_dcc
mobility.wheel_motion.dynamics.wf_c_max_wheel_vel
mobility.wheel_motion.dynamics.ir_drag_max_lin_vel
mobility.wheel_motion.dynamics.ir_drag_max_ang_vel
mobility.wheel_motion.dynamics.ir_drag_max_lat_acc
mobility.wheel_motion.dynamics.ir_drag_max_lin_acc
mobility.wheel_motion.dynamics.ir_drag_max_lin_dcc
mobility.wheel_motion.dynamics.ir_drag_max_ang_acc
mobility.wheel_motion.dynamics.ir_drag_max_ang_dcc
mobility.wheel_motion.dynamics.ir_drag_max_wheel_vel
mobility.wheel_motion.move_pose.d_d
mobility.wheel_motion.move_pose.th_d
mobility.wheel_motion.move_pose.k_d_b_scale
mobility.wheel_motion.move_pose.k_d_b_min
mobility.wheel_motion.move_pose.k_d_b_max
mobility.wheel_motion.move_pose.k_p_b_scale
0.75
mobility.wheel_motion.move_pose.k_p_e_scale
0.25
mobility.wheel_motion.move_pose.k_p
mobility.wheel_motion.move_pose.k_t
mobility.wheel_motion.move_pose.k_v
mobility.wheel_motion.move_pose.k_th_zero
mobility.wheel_motion.move_pose.k_th_min
mobility.wheel_motion.move_pose.d_e_max
mobility.wheel_motion.rotate.th_d
mobility.wheel_motion.rotate.k_t
mobility.wheel_motion.rotate.k_th_dir_min
mobility.wheel_motion.move_dist.d_d
mobility.wheel_motion.move_dist.th_d
mobility.wheel_motion.move_dist.k_p_scale
mobility.wheel_motion.move_dist.k_p
mobility.wheel_motion.move_dist.k_t
mobility.wheel_motion.move_dist.k_v
mobility.wheel_motion.move_dist.k_th_zero
mobility.wheel_motion.move_dist.k_th_min
mobility.wheel_motion.move_dist.k_th_dir_min
mobility.wheel_motion.move_dist.d_e_max
mobility.wheel_motion.reach_line.d_d
mobility.wheel_motion.reach_line.th_d
mobility.wheel_motion.reach_line.k_p
mobility.wheel_motion.reach_line.k_t
mobility.wheel_motion.reach_line.k_v
mobility.wheel_motion.reach_line.k_th_zero
mobility.wheel_motion.reach_line.k_th_min
mobility.wheel_motion.reach_line.k_th_dir_min
mobility.wheel_motion.reach_line.d_e_max
mobility.wheel_motion.move_to.d_d
mobility.wheel_motion.move_to.th_d
mobility.wheel_motion.move_to.k_p
mobility.wheel_motion.move_to.k_t
mobility.wheel_motion.move_to.k_v
mobility.wheel_motion.move_to.k_th_zero
mobility.wheel_motion.move_to.k_th_min
mobility.wheel_motion.move_to.k_th_dir_min
mobility.wheel_motion.move_to.d_e_max
mobility.wheel_motion.turn_to.th_d
mobility.wheel_motion.turn_to.k_p
mobility.wheel_motion.turn_to.k_t
mobility.wheel_motion.turn_to.k_v
mobility.wheel_motion.turn_to.k_th_zero
mobility.wheel_motion.turn_to.k_th_min
mobility.wheel_motion.turn_to.k_th_dir_min
mobility.wheel_motion.turn_to.d_e_max
mobility.wheel_motion.follow_circle.k_f
0.0075
mobility.wheel_motion.follow_circle.k_d
mobility.wheel_motion.follow_circle.k_v
mobility.wheel_motion.follow_circle.k_th_min
mobility.wheel_motion.follow_line.d_d
mobility.wheel_motion.follow_line.k_f
0.004
mobility.wheel_motion.follow_line.k_d
mobility.wheel_motion.follow_line.k_v
mobility.wheel_motion.follow_line.k_th_min
mobility.wheel_motion.follow_wall.k_f
mobility.wheel_motion.follow_wall.k_d
0.707
mobility.wheel_motion.follow_wall.k_v
mobility.wheel_motion.follow_wall.k_th_min
mobility.wheel_motion.follow_wall.target_dist1
60.0
mobility.wheel_motion.follow_wall.target_dist2
mobility.wheel_motion.follow_wall.after_sb_count_max
mobility.wheel_motion.follow_wall.after_sb_margin
mobility.wheel_motion.follow_wall.emgc_obs_flag_latch
mobility.wheel_motion.follow_wall.a_softB_rot_deg
mobility.wheel_motion.follow_wall.a_softB_backward_dist
30.0
mobility.wheel_motion.follow_wall.a_softB_backward_cnt
mobility.wheel_motion.follow_wall.a_softB_appr_time
mobility.wheel_motion.follow_wall.after_sb_msg_out_level
mobility.wheel_motion.follow_wall.rot_deg_after_corner_clean
mobility.wheel_motion.follow_wall.after_corner_clean_appr_time
mobility.wheel_motion.follow_wall.after_corner_clean_appr_add_rotate_time
mobility.wheel_motion.follow_wall.wallcheck_max_error_threshold
150.0
mobility.wheel_motion.follow_wall.wallcheck_avg_error_threshold
12.0
mobility.wheel_motion.follow_wall.wallcheck_angle_threshold
mobility.wheel_motion.follow_wall.weak_wallcheck_max_error_threshold
1000.0
mobility.wheel_motion.follow_wall.weak_wallcheck_avg_error_threshold
15.0
mobility.wheel_motion.follow_wall.weak_wallcheck_angle_threshold
mobility.wheel_motion.follow_wall.weak_wall_add_angle
mobility.wheel_motion.follow_wall.approach_obs_vel
mobility.wheel_motion.follow_wall.rotate_check_radius
mobility.wheel_motion.follow_wall.rotate_check_radius_inner
mobility.wheel_motion.follow_wall.rotate_check_width
mobility.wheel_motion.follow_wall.enable_VG_move_back
mobility.wheel_motion.follow_wall.VG_back_dist
mobility.wheel_motion.follow_wall.VG_min_rotate_angle
mobility.wheel_motion.follow_wall.VG_detect_latch_num
mobility.wheel_motion.follow_wall.VG_stuck_detect_latch_num
mobility.wheel_motion.follow_wall.VG_stuck_cnt_thres
mobility.wheel_motion.follow_wall.VG_stuck_cnt_reset_at_WFinit
mobility.wheel_motion.follow_wall.gyro_stop_enable
mobility.wheel_motion.follow_wall.gyro_stop_interval
mobility.wheel_motion.follow_wall.gyro_stop_duration
mobility.wheel_motion.follow_wall.print_log
mobility.wheel_motion.follow_wall.WF_base_msglevel
mobility.wheel_motion.follow_wall.WF_sub_msglevel
mobility.wheel_motion.follow_wall.arc_estimation
mobility.wheel_motion.follow_wall.arc_estimation.msg_out_level
mobility.wheel_motion.follow_wall.arc_estimation.arc_check_ignore_flag
mobility.wheel_motion.follow_wall.arc_estimation.use_ransac_in_arc_check
mobility.wheel_motion.follow_wall.arc_estimation.line_check_ignore_flag
mobility.wheel_motion.follow_wall.arc_estimation.line_ratio_check
mobility.wheel_motion.follow_wall.arc_estimation.use_ransac_in_line_check
mobility.wheel_motion.follow_wall.arc_estimation.line_additional_move_fw_mode
mobility.wheel_motion.follow_wall.arc_estimation.final_line_dec_ratio_thres
mobility.wheel_motion.follow_wall.arc_estimation.final_arc_dec_ratio_thres
mobility.wheel_motion.follow_wall.arc_estimation.sensor_array_valid_dist
600.
mobility.wheel_motion.follow_wall.arc_estimation.max_line_cand_num
mobility.wheel_motion.follow_wall.arc_estimation.max_arc_cand_num
mobility.wheel_motion.follow_wall.arc_estimation.arc_dist_thres_to_use_min
mobility.wheel_motion.follow_wall.arc_estimation.arc_dist_thres_min_total
mobility.wheel_motion.follow_wall.arc_estimation.line_dist_thres_to_use_min
mobility.wheel_motion.follow_wall.arc_estimation.line_dist_thres_min_total
mobility.wheel_motion.follow_wall.arc_estimation.radius_margin
mobility.wheel_motion.follow_wall.arc_estimation.arc_radius_max_to_line
mobility.wheel_motion.follow_wall.arc_estimation.arc_radius_small_to_original
mobility.wheel_motion.follow_wall.arc_estimation.line_wf_margin_dist
mobility.wheel_motion.follow_wall.arc_estimation.line_ratio_thres
1.02
mobility.wheel_motion.follow_wall.arc_estimation.ransac_line_dist_thres
0.35
mobility.wheel_motion.follow_wall.arc_estimation.ransac_line_cost_thres_ratio
mobility.wheel_motion.follow_wall.arc_estimation.ransac_line_max_iteration_num
mobility.wheel_motion.follow_wall.arc_estimation.ransac_line_stop_ratio
0.80
mobility.wheel_motion.follow_wall.arc_estimation.ransac_line_dist_out_mean_thres
mobility.wheel_motion.follow_wall.arc_estimation.ransac_line_base_l_pt_num
mobility.wheel_motion.follow_wall.arc_estimation.ransac_circle_dist_thres
mobility.wheel_motion.follow_wall.arc_estimation.ransac_circle_cost_thres_ratio
mobility.wheel_motion.follow_wall.arc_estimation.ransac_circle_max_iteration_num
mobility.wheel_motion.follow_wall.arc_estimation.ransac_circle_stop_ratio
mobility.wheel_motion.follow_wall.arc_estimation.ransac_circle_dist_out_mean_thres
mobility.wheel_motion.follow_wall.arc_estimation.ransac_circle_base_c_pt_num
mobility.wheel_motion.follow_wall.arc_estimation.outlier_max_dist_thres
mobility.wheel_motion.follow_wall.arc_estimation.outlier_ratio_thres
mobility.wheel_motion.follow_wall.arc_estimation.error_mean_thres
mobility.wheel_motion.follow_wall.arc_estimation.error_std_thres
mobility.wheel_motion.follow_wall.arc_estimation.wse_outlier_ratio_weight
mobility.wheel_motion.follow_wall.arc_estimation.wse_error_arc_mean_weight
mobility.wheel_motion.follow_wall.arc_estimation.wse_dec_cand_weight
mobility.wheel_motion.follow_wall.arc_estimation.wse_wsum_ignore_thres
0.99
mobility.wheel_motion.cubic_spline.stop
mobility.wheel_motion.cubic_spline.stop.show_log
mobility.wheel_motion.cubic_spline.stop.completion_vel
mobility.wheel_motion.cubic_spline.stop.emc
mobility.wheel_motion.cubic_spline.stop.emc.stop_dist
mobility.wheel_motion.cubic_spline.stop.normal.default_stop_dist
mobility.wheel_motion.cubic_spline.slowdown_returntonormal_cubic
mobility.wheel_motion.cubic_spline.slowdown.t_init
mobility.wheel_motion.cubic_spline.slowdown.show_log
mobility.wheel_motion.cubic_spline.slowdown.use_in_appr_obs
mobility.wheel_motion.cubic_spline.returntonormal.t_init
mobility.wheel_motion.cubic_spline.returntonormal.show_log
mobility.wheel_motion.cubic_spline.returntonormal.use_in_appr_obs
mobility.wheel_motion.cubic_spline.returntonormal.min_initial_rem_t
0.05
15:38:36
Jan 18 2017
/usr/apps/robot-network/version.txt
Release-Product
Debug
Release
!INVALID!
basic_string::substr
%d-%02d-%02d %02d:%02d:%02d
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
@@@@@@@[CVCRobotBase] vcSlipAngleInRotateLocked - Slip ERROR \n
@@@@@@@[CVCRobotBase] vcSlipAngleInRotateLocked -> _DetectSlipDuringBackwardMotion \n
@@@@@@@[CVCRobotBase] vcSlipAngleInRotateLocked\n
@@@@@@@@@@vcLockBottomShort\n
@@@@@@@@@@vcLockBottomLong\n
@@@@@@@@@@unstable Forward Slip\n
Lng %d vDif %4.2f vGyr %4.2f Sht %d fwd %d\n
@@@@@@@@ continuous RT Slip\n
@@@@@@@@ continuous RT Slip, but _DetectSlipDuringBackwardMotion\n
@@@@@@@@@@_DetectSlipBackSlant\n
@@@@@@@@@@_DetectSlipBackSlant_cln\n
BCK v %f w %f now_acc_x %d avg_acc_x %f cln_cnt %d cln_lch %d thr %d\n
@@@@@@@@@@_DetectSlipDuringBackwardMotion1\n
@@@@@@@@@@_DetectSlipDuringBackwardMotion2\n
BCKWDMTN v %f v %f cnt1 %d cnt2 %d thr1 %d thr2 %d\n
[CSlipManager] setSlipOff %d\n
[CSlipManager] setClimbOff %d\n
~serial
open
\b\t\v\f\r
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/common/io/serial.cpp
call close()\n
open() error! (%d, %s)\n
Fail to fcntl\n
1200
2400
4800
9600
19200
38400
57600
INVALID
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(const char*, _IO_FILE*), boost::_bi::list2<boost::arg<1>, boost::_bi::value<_IO_FILE*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(_IO_FILE*), boost::_bi::list1<boost::_bi::value<_IO_FILE*> > >]
socket() error!
ioctl() error!
UNIX
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
recv_thread_fn_handler_chr
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, tserial, void*>, boost::_bi::list2<boost::_bi::value<tserial*>, boost::arg<1> > >]
 * %s thread (id=%s)
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/common/io/tserial.cpp
[%s] serial::recv() returns %d (%s)\n
send
receive
created and started.\n
created and starting.\n
stopped and removed.\n
exited and removed.\n
send thread
recv thread
flush
recv
recv_thread_fn_handler_str
recv_thread_fn_handler_chr
send_thread_fn
recv_thread_fn_buffer
send
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, tsock, void*>, boost::_bi::list2<boost::_bi::value<tsock*>, boost::arg<1> > >]
open_client_preproc
open_server_preproc
open_server_postproc
serv_thread_fn
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/common/io/tsock.cpp
already closed!\n
not client!\n
DO NOT call tsock::recv in %s mode!\n
[%s] sock::recv() returns %d (%s)\n
server
[%s] sock::send() returns %d (%s)\n
sock::byte_inque() returns %d!\n
[%s] sock::recv returns %d (%s)\n
already open!\n
tio::check_arg error!\n
tio::check_args() returns -1\n
sock::listen() returns -1 (%s)!\n
server thread
Fail to remove()\n
sock::accept() waiting connection!\n
%s client %d
[%s] sock::accept() returns %d (%s)\n
THREAD_AND_CHAR_HANDLER
THREAD_AND_STREAM_HANDLER
THREAD_AND_BUFFER
DIRECT
Bmap(%dcells, %.0fmm)\n
    \t
 %d
\n    \t
%d |\t
 %d |\t
 %X
| %d\n
|  %d\n
 j/i\t
map(%d, %.0fmm) Error: Invalid<%d> < min(%d,%d), max(%d,%d) >)\n
### CCellMap::SaveMap %s (%d-%02d-%02d %02d:%02d:%02d)\n
Fail to fread()\n
m_XYQMapShift x %.1f %.1f %.1f\n
#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*#*
Searching %c_%03d.map...
/mnt/storage/%c_%03d.map
File no exists.
File exists
JPH : Saving %s\n
### CCellMap::SavePose idx = %d, size = %d \n
SendText
/CDataNum = %d\n
CellMap Thread Started for SAVE_REC_DATA!!\n
CellMap Thread Started!!\n
CellMap Thread Closed!!\n
#### m_fsys_space_init is failed\n
CellMap_rec
CellMap:SendData
CellMap
G/Map Pose Update 1!!%.1f, %.1f, %.1f\r\n
SendText() (*it)       : %s\n
SendText() prev_string : %s\n
SendText() send_string : %s\n
SendText() prev_string : %s\n\n
SendText() : send_count = %d\n
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/common/map/CellMapManager.cpp
send_count = %d\n
[SendVirtualSensor] %8d : %2d (%+6.0f, %+6.0f) %2d\n
[SendVirtualSensor] %8d\n
Sector
[STATUS.MAP_BUILDING] Land -> Lift\n
[STATUS.MAP_BUILDING] Lift -> Land\n
[AddVirtualSensor] %8d : %2d (%+6.0f, %+6.0f) %2d\n
deque::_M_new_elements_at_front
deque::_M_new_elements_at_back
[SendVirtualGate] fnc_size: %d\n
[VirtualGatePoint] <%d> [%.1f %.1f] [%.1f %.1f]\n
available space %d %d\n
[%08d] RobotMon Thread Loop!\n
rec_min_size exceeded!: %d %d\n
CellMap Viewer - m_pSockCellMap is NULL!\n
RobotMon disconnected!\n
CellMap thread duration %d ms %d ms %d ms\n
`jE<
Astatic const char* boost::detail::sp_typeid_<T>::name() [with T = void]
f_?ffVC33
mCffXC33IC
AC33ICffXC
mC33
CffVC
K!?]
%5.2f
/dev/urandom
INVALID INDEX!
ang=%.0f dist=%.0f exception=%s safe=%s
DANGEROUSAREA
CLIFF
BUMPER
MB_TANGLE
SB_TANGLE
WHEELSTUCK
MAGNETIC
LIFT
STUCK
DOCKING_ST
INCLINE
upper=(%+6.0f,%+6.0f) lower=(%+6.0f,%+6.0f) left=%5.0f right=%5.0f ccw=%+4.0f cw=%+4.0f
ang=%.0f dist=%.0f exception=%s safe=%s corner=%s
sinfo=%s
UPPER
LOWER
LEFT
RIGHT
getlimit() error!
can't ignore SIGHUP
2nd fork() error!
can't change directory
/dev/null
daemonized. (pid=%d)
unexpected file descriptors %d %d %d
CLEAR_OVC
NORMAL
%s %s %s %s
%s %s
BUMP
BOTT
%s %s %s
SLIP
EMC_STOP
DUST
MAGNET
SG_FENCE
SG_GATE
WSTUCK
CLIMB
ST_FENCE
EMC_TURN
NARROW_PASS
UPPER_STUCK
SOFT_BUMP
BACK_CLIMB
%03d
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
SUCCESS
FAIL
%s%s%s
/proc/mounts
===================== dummy_ol_sensor::init() \n
(%8ld)[OL_SENSOR] Grab buffer index = %d\n
/tmp/capture.front.0-0.yuv
/tmp/capture.front.0-1.yuv
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
eeprom_create fail [%x]
eeprom_prepare fail [%x]
[WiLD] center_x=%f, center_y=%f, wf_left=%d, wf_right=%d , rotation = %lf from EEPROM\n
[WiLD]EEPROM checksum error : center(%f, %f) wf(%d, %d) rotation(%lf) cal_chksum=%d, read_chksum = %d from EEPROM\n
[WiLD]EEPROM Init failed!\n
eeprom_unprepare fail [%x]\n
eeprom_destroy fail [%x]\n
[WiLD] center_x=%f, center_y=%f, wf_left=%d, wf_right=%d rotation=%lf from max.conf\n
[WiLD] center_x=%f, center_y=%f, wf_left=%d, wf_right=%d rotation=%lf from default\n
[WiLD] center_x=%f, center_y=%f from default\n
[WiLD] rotation=%lf from default\n
[WiLD] wf_left=%d, wf_right=%d from default\n
dist_table.dat
[WiLD] Open %s\n
[WiLD] Cannot Open %s\n
/dev/i2c-2
/tmp/full_edge_image_%02d.yuv
[WiLD Cal] Can't open %s\n
[WiLD Cal] min_y_pt is too big %d\n
/tmp/out_side_image_%02d.yuv
[WiLD] subpixel init = %ldms\n
\n\n[WiLD Cal] START try=%d, success=%d\n
[WiLD Cal] center point is too far (%f, %f)\n
[WiLD Cal] cx=%f, cy=%f\n
[WiLD Cal] initialize after Center CAL\n
[WiLD Cal] adjust_y is too bit tbl=%0.3f, cur=%0.3f, cal_adjust_y = %0.3f\n
[WiLD Cal] adjust_y -> tbl=%0.3f, cur=%0.3f, center_y = %0.3f -> %0.3f\n
[WiLD Cal] rotation = %f (min:%d, max:%d)\n
[WiLD CAL] rotation is too big!\n
[WiLD CAL] wf point is too far [L]%d, [R]%d\n
[WiLD Cal] wf_l = %d, wf_r = %d\n
[WiLD Cal] END %ldms\n\n
\n\n[WiLD Cal] final\n
[WiLD Cal] center(%f,%f,%f), wf(%d,%d), chksum= %d\n
[WiLD CAL]eeprom_write fail !!!\n
 [WiLD CAL] Success!\n
[WiLD CAL] eeprom_write fail !!!\n
[WiLD CAL ERR]eeprom_write fail !!!
 [WiLD CAL] Success!
/tmp/fine_cal_image.yuv
 [WiLD CAL] write failed!
[WiLD Cal] Find Two_Corners fail!
[WiLD Cal] center_x = %0.3f -> %d, center_y=%0.3f -> %d \n
[WiLD Cal] rebase center_x = %d, center_y = %d\n
 [WiLD CAL] center point is too far (%d, %d)\n
PKT_REP_PA
PKT_CTL_AP
PKT_REP_NA
PKT_CTL_AN
PKT_SRT_NA
PKT_SRT_AN
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
a2n mode task %d\n
 Gain(%d, %d, %d, %d, %d)\n
[PKT.BUILDER] A2N SRT Packet\n
 * Prj. Number:     %d\n
 * Model type:      %d\n
 * OS build No.:    %d\n
 * SW version:      %d.%d\n
 * SW(net) version: %d.%d\n
 * SW SCM revision: %x(%d)\n
 * SW build date:   20%02d/%02d/%02d\n
 * OS/SW Update:    success(%d), fail(%d)\n
 * Camera Error:    c_cam(%d), c_grab(%d), w_cam(%d)\n
  %-32.32s =       %02X  %10d\n
m_arm2nxp.a2m.r_count
  %-32.32s =       %02X  %+10d\n
m_arm2nxp.a2m.error
m_arm2nxp.a2m.u_r_cmd_main.c_r_cmd_main[0]
m_arm2nxp.a2m.u_r_cmd_main.c_r_cmd_main[1]
m_arm2nxp.a2m.u_r_cmd_etc.c_r_cmd_etc
m_arm2nxp.a2m.u_r_cmd_reserved.c_r_cmd_reserved
m_arm2nxp.a2m.u_r_cmd_debug.c_r_cmd_debug
m_arm2nxp.a2m.u_cmd_main.c_cmd_main
m_arm2nxp.a2m.u_cmd_reserved.c_cmd_reserved
m_arm2nxp.a2m.u_cmd_debug.c_cmd_debug
m_arm2nxp.a2m.u_sts_reset.c_sts_reset
m_arm2nxp.a2m.u_navi_info.c_navi_info[i]
m_arm2nxp.a2m.u_info_etc.c_info_etc
  %-32.32s =     %04X  %+10d\n
m_arm2nxp.a2m.lin_vel
m_arm2nxp.a2m.ang_vel
m_arm2nxp.a2m.dist[i]
m_arm2nxp.a2m.wf_dist[i]
m_arm2nxp.a2m.view_data[i]
m_arm2nxp.a2m.reserved[i]
m_count
m_command
m_option.all
m_motor_ctl.all
m_lin_vel
m_ang_vel
m_p_gain
m_i_gain
m_d_gain
m_db_pwm
m_custom_cmd.all
m_config.all
m_status.all
[PKT.REP_NA] D(%d %02X %02X)\n
m_nxp2arm.m2a.count
m_nxp2arm.m2a.micom_mode
m_nxp2arm.m2a.micom_status
m_nxp2arm.m2a.u_micom_err_code.c_micom_err_code
m_nxp2arm.m2a.u_r_cmd_main.c_r_cmd_main
m_nxp2arm.m2a.u_r_cmd_reserved.c_r_cmd_reserved
m_nxp2arm.m2a.u_r_cmd_debug.c_r_cmd_debug
m_nxp2arm.m2a.u_cmd_main.c_cmd_main[0]
m_nxp2arm.m2a.u_cmd_main.c_cmd_main[1]
m_nxp2arm.m2a.u_cmd_etc.c_cmd_etc
m_nxp2arm.m2a.u_cmd_reserved.c_cmd_reserved
m_nxp2arm.m2a.u_cmd_debug.c_cmd_debug
m_nxp2arm.m2a.cmd_sound_type
m_nxp2arm.m2a.cmd_sound_id
m_nxp2arm.m2a.u_cmd_reset.c_cmd_reset
m_nxp2arm.m2a.u_hand_op.c_hand_op
m_nxp2arm.m2a.u_docking.c_docking[i]
m_nxp2arm.m2a.u_info_etc.c_info_etc
  %-32.32s =     %04X  %10d\n
m_nxp2arm.m2a.whl_enc[i]
m_nxp2arm.m2a.whl_vel[i]
  %-32.32s = %08X  %+10d\n
m_nxp2arm.m2a.whl_pwm[i]
m_nxp2arm.m2a.u_sts_wheel.c_sts_wheel
m_nxp2arm.m2a.u_sts_cln_tool.c_sts_cln_tool
m_nxp2arm.m2a.acc_x
m_nxp2arm.m2a.acc_y
m_nxp2arm.m2a.acc_z
m_nxp2arm.m2a.gyro_index
m_nxp2arm.m2a.gyro_angle
m_nxp2arm.m2a.gyro_angle_pitch
m_nxp2arm.m2a.gyro_angle_roll
m_nxp2arm.m2a.u_dist.c_dist[i]
m_nxp2arm.m2a.u_sen_etc.c_sen_etc[i]
m_nxp2arm.m2a.u_charger.c_charger
m_nxp2arm.m2a.view_data[i]
m_nxp2arm.m2a.reserved[i]
[PKT.REP_PA] D(%d %02X %02X)\n
m_motor_sts.all
  %-32.32s = %08lX  %+10ld\n
m_pose_x
m_pose_y
m_pose_th
m_lw_enc
m_rw_enc
m_lw_enc_d
m_rw_enc_d
m_ir_range[i]
m_ir_bottom[i]
m_gyro_index
m_gyro_angle
m_acc_index
m_acc_x
m_acc_y
m_acc_z
m_remocon
m_remorcv[i].all
m_etc_sensor0.all
m_etc_sensor1.all
m_etc_sensor2.all
m_arm2nxp_st.a2m_st.model_project
m_arm2nxp_st.a2m_st.u_model_type.c_model_type
m_arm2nxp_st.a2m_st.os_ver
m_arm2nxp_st.a2m_st.exe_ver
m_arm2nxp_st.a2m_st.net_ver
m_arm2nxp_st.a2m_st.scm_rev
m_arm2nxp_st.a2m_st.year
m_arm2nxp_st.a2m_st.month
m_arm2nxp_st.a2m_st.day
m_arm2nxp_st.a2m_st.u_init_check.c_init_check
m_arm2nxp_st.a2m_st.reserved[i]
m_nxp2arm_st.m2a_st.main_ver
m_nxp2arm_st.m2a_st.sensor_ver
m_nxp2arm_st.m2a_st.display_ver
m_nxp2arm_st.m2a_st.model_year
m_nxp2arm_st.m2a_st.model_nation
m_nxp2arm_st.m2a_st.model_project
m_nxp2arm_st.m2a_st.u_model_type.c_model_type
m_nxp2arm_st.m2a_st.wheel_base_gap
m_nxp2arm_st.m2a_st.wheel_gear_ratio
m_nxp2arm_st.m2a_st.wheel_radius
m_nxp2arm_st.m2a_st.wheel_enc_ppr
m_nxp2arm_st.m2a_st.wheel_enc_freq_mul
m_nxp2arm_st.m2a_st.u_navi_info.c_navi_info
m_nxp2arm_st.m2a_st.u_etc_info.c_etc_info
m_nxp2arm_st.m2a_st.reserved[i]
%-12s index: %3d dx: %4d dy: %4d dz: %4d raw_dx: %4d raw_dy: %4d raw_dz: %4d\n
acceleration
%-12s: left=%3d front=%3d right=%3d\n
%-12s: left=%d right=%d left_front=%d right_front=%d left_side=%d right_side=%d cont=%d\n
%-12s: on=%d ovc=%d pwm=%+6d(0x%04x)\n
\t%-12s [WLRCS] FL: %d%d%d%d%d FR: %d%d%d%d%d SL: %d%d%d%d%d SR: %d%d%d%d%d RL: %d%d%d%d%d RR: %d%d%d%d%d \n\r\t\t\t     FL: %d%d%d%d%d FR: %d%d%d%d%d SL: %d%d%d%d%d SR: %d%d%d%d%d RL: %d%d%d%d%d RR: %d%d%d%d%d %d\n
deque::_M_range_check
%-12s: magnet=%d dust=%d climb=%d back_climb=%d %d station=%d gyro_resetting=%d cleaning=%d\n
              tangle      (drum=%d l_sb=%d r_sb=%d l_wheel=%d r_wheel=%d)\n
              smart guard (fence=%d halo=%d gate=%d) station (halo=%d, dir = %0.1f)\n
\t\t\t\trotate_halo = %d, narrow_pass = %d virtual_rear = %d bott_latch_dir = %d\n
etc.
%-12s: index= %3d angle= %+7.2f angle_pitch= %+7.2f angle_roll= %+7.2f ang_vel= %+7.2f ang_vel_raw1= %4d ang_vel_raw2= %4d\n
%-12s: [0]=%d [1]=%d [2]=%d [3]=%d\n
%-12s: f_l[%d] f_r[%d] s_l[%d] s_r[%d] r_l[%d] r_r[%d]\n
%-12s:
%3d
%-12s: count=%02X m_ver=%003d s_ver=%003d d_ver=%003d mode=%2d option=0x%02x micom=(mode:%d,sts:%d,is_err:%d,err_info:%d)\n
              model(Year=%d Nation=%d Prj=%d Type=(%d %d) Off(Dst=%d Slp=%d Clm=%d Err=%d slm=%d) EraNet=%d FltClg=%d SucErr=%d SftFlr=%d ShtInfo=%d ClnStn=%d alwCln=%d alwInf=%d NoRIr=%d\n
              reset(gyro=%d slam=%d map=%d planner=%d sector=%d) station=%d snd_type=%d snd=%3d dbg=%3d reset_arm_flag=%d eeprom_set=%d cam=(%d,%d)\n
%+4d=%3d
%-12s: count=%3d command=%3d(0x%02x) option=%3d(0x%02x) edge=%d resume=%d\n
%-12s: on=%d ovc=%d pos=%+4.1f vel=%4.1f\n
%-12s: left=%5.0f front=%5.0f right=%5.0f\n
p0x(`
%-12s: SIG [%02d] DIR [%02d]\n
remocon
POWER
RETURN
FORWARD
BACKWARD
AUTO
SPOT
MANUAL
RESERV
TIME
UVLAMP
DOCKED
CHARGED
%d=0x%02x
%-12s: type=%d type_latch=%d dir=%d dir_latch=%d slope=%d rt_err_level=%d\n
slip_manager
SLOPE_FRONT
SLOPE_BACK
FRONT
sonar:  grp = %d\n
%-12s: front_left=%5.0f  front=%5.0f  front_right=%5.0f\n
%-12s:       left=%5.0f   rear=%5.0f        right=%5.0f\n
sonar
%-12s: type=%d  dir=%d\n
%-12s: left=%d right=%d\n
%-12s: start/stop=%d docking=%d\n
switch
%-12s: left= %3d [%d] front= %3d [%d] right= %3d [%d] type= [%d] \n
%-12s: on=%d ovc=%d vel=%+6.1f enc=0x%04x enc_d=%+4d pwm=0x%04x\n
cmd sts sub_s  time ctime on ovc       x       y       q      v      w\n
----------------------------------------------------------------------\n
%3d %3d %5d %5d %5d %2d %3d %+7.1f %+7.1f %+7.2f %+6.1f %+6.1f\n
PROCESSING
ALMOSTCOMP
COMPLETED
FAILED
%-12s: p=(%+6.0f,%+6.0f,%+6.1f) v=%+6.1f w=%+6.1f l=%+6.1d r=%+6.1d pl=%4d pr=%4d\n
%-12s  on=%d ovc=%d enc=(0x%04x,0x%04x) enc_d=(%+4d,%+4d)\n
PIC-Board
NXP-Board
ir-range
omni-laser
ir-bottom
bumper
suspension
upp-dist
RCV_IR_POSITION
IR-DRAG
DOCK SIG
pabo:  %+7.1f %+7.1f %+6.1f\n
arbo:  %+7.1f %+7.1f %+6.1f\n
fused: %+7.1f %+7.1f %+6.1f\n
Global
Local
terminate
\nid %d setpriority(%d) OK!\n
 \nid %d setpriority(%d) error!\n
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/common/thread/thread.cpp
 (id=%s)\n
Removing %s (id=%s)
done.\n
Starting %s (id=%s)
Stopping %s (id=%s)
(terminating)...
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, alsa_player, void*>, boost::_bi::list2<boost::_bi::value<alsa_player*>, boost::arg<1> > >]
cannot open audio device %s (%s)\n
cannot allocate hardware parameter structure (%s)\n
cannot initialize hardware parameter structure (%s)\n
cannot set access type (%s)\n
cannot set sample format (%s)\n
cannot set sample rate (%s)\n
cannot set channel count (%s)\n
cannot set parameters (%s)\n
cannot prepare audio interface for use (%s)\n
snd_pcm_close() returns %d (%s).\n
tizen_aui_play play failed with 0x%x\n
Closing ALSA playback...
 * playback thread (id=%s)
stopped and removed.
error! (Not initialized)
Initializing ALSA playback (%s)...
alsa thread
 * create playback thread error! (%d %s)
created and started.
|Iter#:%d|
CoLinear!(%7.3f- %7.3f=%7.3f)\n
[(RS)RESULT(X)[%7.3f||%3.2f|%3.2f]: OutLRo(%d): %7.3f, OutLMD: %7.3f, E_Mean(%d): %7.3f, E_Std(%d): %7.3f
[(RS)RESULT(O)[%7.3f||%3.2f|%3.2f]]: OutLR(%d): %7.3f, OutLMD: %7.3f, E_Mean(%d): %7.3f, E_Std(%d): %7.3f
[RESULT(R_NaN)=>IGNORE \n
(ArcRansac)[%d](xyr)(%3.2f,%3.2f,  (((%7.3f))) [[mu=[%7.6f]]] ) Cost:%3.1f, InR: %3.2f\n
            (Total)mean,std(%7.3lf, %7.3lf)(Out)mean,std(%7.3lf, %7.3lf)\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
[%s][%8.3f ms]
ch = 0x%02X (buf size = %3d)\n
ch = 0x%02X (buf size = %3d) -> %s (pkt_len = %d)\n
TOO SHORT PKT LEN
ch = 0x%02X (buf size = %3d) -> %s (buf_len = %d)\n
TOO SHORT BUF LEN
INVALID PKT LEN
ch = 0x%02X (buf size = %3d) -> %s (read SOH = 0x%02X)\n
SOH NOT FOUND
ch = 0x%02X (buf size = %3d) -> %s (read pkt_id = %02X)\n
INVALID PKT ID
ch = 0x%02X (buf size = %3d) -> %s (pkt_id, pkt_len = %d)\n
PKT LEN MISMATCH
ch = 0x%02X (buf size = %3d) -> %s\n
************************** -> %d-th %s : %d bytes\n
RECV
************************** -> %s (0x%02X, 0x%02X)\n
COUNT DISCONT ERROR!
************************** -> %s\n
CHKSUM ERROR!
%s report:\n
    total = %d loop\n
    min. = %.2f ms, max. = %.2f ms\n
    ave. = %.2f ms, std. dev. = %.4f ms\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
/opt/app_ro/aui/
mm_sound_volume_set_value 0x%x\n
%s%03d.wav
[SOUND PLAYER] %3d : playing wave file %s...
Fail!\n
%-20s : %ld %ld\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
[APPROACH OBS]\n
[APPROACH OBS] terminate softbump try motion cnt = %d, dir_cnt = %d\n
[APPROACH_OBS] shutter standby down\n
 A2=
=2>
 AsB
th_t = %+6.1f, rc.req_th = %+6.1f, l = %+6.1f
INIT
APPROACH
DEADZONE
follow-circle completed!
FORCEDTIME
;WFNormal -- LV:%5.0f AV:%5.0f \n
EmgObs1 -- LV:%5.0f AV:%5.0f \n
EmgObs2 -- LV:%5.0f AV:%5.0f \n
WFEmgcBump case0 : %5.5f \n
WFEmgcBump case1 : %5.5f \n
WFEmgcBump case2 : %d \n
WFEmgcBump case3
WFEmgcOppBump case0 : %5.5f \n
WFEmgcOppBump case1 : %5.5f \n
WFEmgcOppBump case2 : %d \n
WFEmgcOppBump case3
here~
%5d
\n #1 : %5.0f %5.0f %5.0f %5.0f %5.0f %5.0f %5.0f v:%5.0f w:%5.0f gyro:%5.0f,  l:%d , c:%d , r:%d --- lb:%c , cb:%c , rb:%c \n
l:%d , c:%d , r:%d --- lb:%d , cb:%d , rb:%d \n
magnetic_band :%d \n
dAff
(B33IB
xAff
<B33]B
Bstatic const char* boost::detail::sp_typeid_<T>::name() [with T = void]
[WF] DetectingMotion_Obs_WallCheck - wall(strong,weak)=(%d,%d), (area_cnt, angle, err_avg, err_max)=(%d, %3.f, %4.1f,%4.f)\n
[WF]    FindPreturnAngle() - closest obs index=%d, preturn_angle=%d\n
[WF]    FindPreturnAngle() - closest_obs_i=%d, preturn_angle=%.1f, is_weak_wall=%d\n
DETECT DetectingMotion_WheelStuck : %d \n
DETECT DetectingMotion_Stuck : %d \n
DETECT EXCEPTION_STUCK in WF \n
DETECT DetectingMotion_SbTangle : %d \n
DETECT DetectingMotion_MbTangle : %d \n
DETECT DetectingMotion_Magnetic : %d \n
DetectingMotion_Slip ETC \n
m_side_bump_continued m_virtual_rear_halo\n
Detecting#2 Bump side L[%d] R[%d]\n
Detecting Bump Cnt : %d DT [%d:%d:%d:%d] VEL [%.1f %.1f] Contnd: %d\n
[WF] CallWfByFirstEvt : MAGNET\n
[WF] CallWfByFirstEvt : CLIFF\n
[WF] CallWfByFirstEvt : BACK_LIFT\n
[WF] CallWfByFirstEvt : SOFT_BUMP\n
[WF] CallWfByFirstEvt : OBSTACLE\n
[WF] CallWfByFirstEvt : BUMP\n
[WF] CallWfByFirstEvt : SLIP\n
[WF] CallWfByFirstEvt : SG_FENCE\n
[WF] CallWfByFirstEvt : SG_GATE\n
[WF] CallWfByFirstEvt : DOCK HALO\n
[WF] CallWfByFirstEvt : DRUM BRUSH TANGLE\n
[WF] CallWfByFirstEvt : SIDE BRUSH TANGLE\n
[WF] CallWfByFirstEvt : LIFT\n
[WF] CallWfByFirstEvt : WHEEL STUCK\n
[WF] CallWfByFirstEvt : INCLINE\n
[WF] CallWfByFirstEvt : NARROW PASS\n
[WF] CallWfByFirstEvt : UPPER_STUCK\n
WF check Another sensor !\n
Detecting OppBump Cnt : %d DT [%d:%d:%d:%d] VEL [%.1f %.1f] Contnd: %d\n
[WF] ***** STUCK in Virtual Guard (DetectingMotion_SG)\n
\t [WF_sub] WF_EMGC_VW_INIT\n
\t [WF_sub] WF_EMGC_VW_BACKWARD\n
\t [WF_sub] WF_EMGC_VW_ROTATE\n
\t [WF_sub] WF_EMGC_VW_FORWARD\n
[WF]   WFEmgcObs_PCR - Preturn - Half(%3.1f)\n
[WF] terminate softbump try motion cnt = %d, dir_cnt = %d\n
[WF] gyro stop! SUCCESS!!! interval = %d, duration = %d\n
[WF] emgc_obs - no backward, pretun_ange set 90deg\n
\t [WF_sub] emgc_obs rotate start, preturn angle = %0.1f\n
\t [WF_sub] emgc obs rotate completed.ang_travelled = %0.1f\n
\t [WF_sub] emgc obs rotate completed. ang_travelled = %0.1f, pre_completed = %0.1f\n
\t [WF] emgc obs rotate completed. to do adding rotation ang_travelled = %0.1f\n
\t [WF] emgc obs rotate try. to do adding rotation ang_travelled = %0.1f\n
[WF]   WFEmgcObs_PCR - L side bump m_obs_bump_during_rotate_cnt %d\n
[WF]   WFEmgcObs_PCR - R side bump m_obs_bump_during_rotate_cnt %d\n
[WF] EMGC_OBS_PCR step 5!!\n
[WF] WF_EMGC_OBS_PCR_CORNER_CLEAN - 1st shutter standby down\n
[WF] WF_EMGC_OBS_PCR_CORNER_CLEAN - 1st shutter run up, switch up\n
[WF_EMGC_OBS] can't 2nd soft bump. cnt= %d > 750, chang_cnt= %d >= 5\n
[WF] WF_EMGC_OBS_PCR_CORNER_CLEAN - 2nd shutter standby down\n
[WF] WF_EMGC_OBS_PCR_CORNER_CLEAN - 2nd shutter run up, switch up\n
[WF_EMGC_OBS] Detect WALL when after_corner_clean motion, post_CC_time = %0.1f\n
[WF_EMGC_OBS] add rotate after_coner_clean motion, post_CC_time = %0.1f\n
\t [WF_sub] WF_EMGC_OBS_PCR_INIT\n
\t [WF_sub] WF_EMGC_OBS_PCR_APPROACH\n
\t [WF_sub] WF_EMGC_OBS_PCR_REVERSE\n
\t [WF_sub] WF_EMGC_OBS_PCR_ROTATE\n
\t [WF_sub] WF_EMGC_OBS_PCR_FINISH\n
\t [WF_sub] WF_EMGC_OBS_PCR_AFTER_SOFT_BUMP\n
\t [WF_sub] WF_EMGC_OBS_PCR_CORNER_CLEAN\n
\t [WF_sub] WF_EMGC_OBS_PCR_AFTER_CORNER_CLEAN\n
WFEmgcLift m_nRepeatAngCnt : %d \n
WFEmgcWheelstuck m_nRepeatAngCnt : %d \n
bott_cnt %d, clf %d\n
[WFEmgcBump] Bump side Dir[%d]\n
[WFEmgcBump c1] fBAng %.1f tmpAng %.1f fAddAng %.1f dir %d EmgcB %f\n
WFEmgcBump m_nRepeatAngCnt : %d \n
[WFEmgcBump_ApproachWall]   Aft Prev(%3.1f %3.1f) Curr(%3.1f %3.1f) (%3.1f<300)?\n
\t [WF_sub] WF_EMGC_BUMP_BACKWARD\n
\t [WF_sub] WF_EMGC_BUMP_AVOID_OBS\n
\t [WF_sub] WF_EMGC_BUMP_ROTATE\n
\t [WF_sub] WF_EMGC_BUMP_FORWARD\n
\t [WF_sub] WF_EMGC_BUMP_APPROACH_WALL\n
WFEmgcTangleMB m_nRepeatAngCnt : %d \n
WFEmgcTangleSB m_nRepeatAngCnt : %d \n
Stuck in WFEmgcSlip
[WFEmgcOppBump] Bump side Dir[%d]\n
[WFEmgcOppBump c1] fBAng %.1f tmpAng %.1f fAddAng %.1f dir %d EmgcB %f\n
[WFEmgcOppBump_ApproachWall]   Aft Prev(%3.1f %3.1f) Curr(%3.1f %3.1f) (%3.1f<300)?\n
\t [WF_sub] WF_EMGC_OPP_BUMP_BACKWARD\n
\t [WF_sub] WF_EMGC_OPP_BUMP_AVOID_OBS\n
\t [WF_sub] WF_EMGC_OPP_BUMP_ROTATE\n
\t [WF_sub] WF_EMGC_OPP_BUMP_FORWARD\n
\t [WF_sub] WF_EMGC_OPP_BUMP_APPROACH_WALL\n
(Line)[LRansac]Cost:%2.1lf(InlierR:%7.3f)\n
      [LRansac]Cost:%2.1lf(InlierR:%7.3f)\n
\t\t\t                  dmean:%5.2f,dstd:%7.2f(out mean: %5.3f,std:%5.2f )\n
      (dRatio)%7.3f|
Line (dRatio)%7.3f|
\t>> WALL_FOLLOWING_TYPE_NORMAL : \n
\t>> WALL_FOLLOWING_TYPE_CLIFF : \n
\t>> WALL_FOLLOWING_TYPE_CLIFF_C : \n
\t>> WALL_FOLLOWING_TYPE_CLIFF_L : \n
\t>> WALL_FOLLOWING_TYPE_CLIFF_R : \n
\t>> WALL_FOLLOWING_TYPE_OPPBUMP : \n
\t>> WALL_FOLLOWING_TYPE_BUMP : \n
\t>> WALL_FOLLOWING_TYPE_OBSTACL : \n
\t>> WALL_FOLLOWING_TYPE_OBSTACLE_FIRST : \n
\t>> WALL_FOLLOWING_TYPE_SG : \n
\t>> WALL_FOLLOWING_TYPE_MAGNETIC : \n
\t>> WALL_FOLLOWING_TYPE_BACKLIFT : \n
\t>> WALL_FOLLOWING_TYPE_LIFT : \n
\t>> SECTOR_CLEAN_VIA_OBSTACLE_START : \n
\t>> SECTOR_CLEAN_VIA_OBSTACLE_PRE_END_CHECK : \n
\t>> SECTOR_CLEAN_VIA_OBSTACLE_END_CHECK : \n
\t>> SECTOR_CLEAN_MUST_WALL_FW : \n
\t>> SECTOR_CLEAN_MUST_WALL_FW BY SENSOR : \n
\t>> SECTOR_CLEAN_MAIN_DECISION_EW_BY_SENSOR : \n
\t>> WALL_FOLLOWING_TYPE_SLIP : \n
\t>> WALL_FOLLOWING_TYPE_NARROW_PASS : \n
\t>> WALL_FOLLOWING_TYPE_UPPER_STUCK : \n
\t>> WALL_FOLLOWING_TYPE_ESCAPE_BUMP : \n
\t>> WALL_FOLLOWING_TYPE_ESCAPE_UPPER_STUCK : \n
\t>> WALL_FOLLOWING_TYPE_NON : \n
\t>> ERROR STATE:!!!!!!!!!!!!!!!  \n
[[AR_EST]]Cnd:L(%d,%d),R(%d,%d)|
[R:Arc]C(x,y[R])(%5.3f,%5.3f[%6.3f])
[L:Arc]Arc_cand_not_full
[L:Arc]Not long enough
[R:Arc]Arc_cand_not_full
[R:Arc]not long enough
[overR>LINE]\n
[smallR>Assign fixed]\n
[Zero_R>Ignore]\n
|OppCenter-->Ignore|
|[Final]CIRCLE|
|[Final]  LINE  |
|[Final]          |
HS_WF: After_sb_count:%d, t_dist:%5.3f\n
[WF] approach WF Normal- detect bump repetition\n
[WF] approach WF Normal- detect bump long time\n
[WF] approach WF Normal- can't detect bump long time\n
(%d%d)ARC[O:%d] Lvel: %7.3f, Avel: %7.3f
(%d%d)line[OW:%d] Lvel: %7.3f, Avel: %7.3f
|time:%ld ms|\n
[FINAL_RATIO] circle_ratio: %4.3f, line_ratio: %4.3f\n
\t [WF_sub] WF_NORMAL_PCR_INIT\n
\t [WF_sub] WF_NORMAL_PCR_1ST\n
\t [WF_sub] WF_NORMAL_PCR_2ST\n
\t [WF_sub] WF_NORMAL_PCR_NO_OBS\n
Same num %d dir_now %d dir_ra %d dir_prv %d\n
\n\n Too long WF with same direction, changed %d To %d, m_wf_same_dir_cnt %d \n\n\n
Diff num %d dir_now %d dir_ra %d dir_prv %d\n
 >>>>> C00 case<%d>, but Err Off Condition\n
motor_ctl=%s(%d) dyn_ctl=%d v=%+6.0f w=%+6.0f sub_sts=%d\n
 @r_dir = %+2.0f, th_e = %+6.1f, rp.th_d = %+6.1f  >>
REVERSE %c
th_e = %+6.1f\n
DEADZONE %+6.1f > %+6.1f\n
APPROACH %+6.1f > %+6.1f\n
CRUISE   %+6.1f > %+6.1f (%6.1f)\n
\n<static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
!!!!!!!!!!!!STOP(init spline)!!!!!!!!!!!!\n
[STOP] v_c:%5.3f, v_r:%5.3f, tdist: %5.3f, t2v_ratio:%7.6f\n
!!!!!!!!!!!!STOP(NORMAL STOP): t_dist: %5.3f, cur_vel: %5.3f, cmd_vel(initial): %5.3f, t2v_ratio: %7.6f, t_rem_calced: %5.3f\n
CSTOP:Trem:%5.3f V_in:%5.3f V_cur:%5.3f \n
stop: V_in:%5.3f V_cur:%5.3f \n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mobility_subsys, int>, boost::_bi::list2<boost::_bi::value<mobility_subsys*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, mobility_subsys, void*>, boost::_bi::list2<boost::_bi::value<mobility_subsys*>, boost::arg<1> > >]
mobility thread
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
##### [wheel_motion_cont] wheel_base_dist %.1f\n
wheel_motion_cont::report()\n
wheel_motion_cmd:
wheel_motion_sts:\n
motion_output:
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
##### [mx_dead_reckoning] wheel_base_dist %.1f\n
Dead-Reckoning by pabo pose\n
Dead-Reckoning by odometry (forward)\n
Dead-Reckoning by odometry (backward)\n
Dead-Reckoning by odometry (high precision)\n
%8d arbo=(%+8.1f,%+8.1f,%6.1f)\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
[STATUS.EP] sound=%s (%d)\n
uatlas::exec begin
pkt_srt_an sent
[STATUS.EP] First sound play: %d (%ld ms after beginning) (%ld ms after pkt_srt_an sent)\n
[STATUS.EP] First sound play: %d (%ld ms after beginning)\n
[STATUS.EP] First sound play: %d (%ld ms after pkt_srt_an sent)\n
[STATUS.EP] First sound play: %d\n
first sound play
[STATUS.EP]  corner_dt_cnt: %d
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
[STATUS.LOC] Enable  camera\n
[STATUS.LOC] Disable camera\n
[STATUS.LOC] Gyro index diff error! : index_diff=%3d (%3d, %3d) angle_diff=%+7.2f (%+7.2f, %+7.2f)\n
[STATUS.LOC] Gyro angle diff error! : index_diff=%3d (%3d, %3d) angle_diff=%+7.2f (%+7.2f, %+7.2f)\n
R0 :
R2 :
R1 :
R3 :
dist_diff=%+6.3f gyro_angle_diff=%+6.3f r=%+8.1f -> rotation_count=%2d, rotation_flag=%d\n
ldiff = %+6.2f, rdiff = %+6.2f, in_rotation = %d, rotation_flag = %d\n
%8d OD(%+8.1f,%+8.1f,%6.1f), SLAM(%+8.1f,%+8.1f,%6.1f)\n
[PRINT SLIP TYPE]: %s\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
%+f
/mnt/usb/debug/
/mnt/usb
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
[STATUS.SM] Dock[%d] Vel[%.1f %.1f %.1f] bott[%d %d %d], sup[%d %d]\n
[STATUS.SM] cnt[%3d] acc[%4d] clnTool[%d]\n
\n\n\n[[[ HSJ ]]] [[[ Modified ]]] - [1]acc_offset = %d acc_median = %d!!!\n
ACC:
 %3d
\n\n\n[[[ HSJ ]]] [[[ Modified ]]] - [2]acc_offset = %d !!!\n
\n\n\n[[[ HSJ ]]] [[[ Modified ]]] - [3]acc_offset = %d !!!\n
[STATUS.SM] kidnapping_pose = (%+6.1f,%+6.1f,%+6.1f)\n
[STATUS.SM] check_short_dist_detection TRUE\n
chat(%d,%d,%d), latch(%d,%d,%d), state(%d,%d,%d), val(%3d,%3d,%3d), val(%3d,%3d,%3d)\n
virtual sensor rear_obstacle_count:%d\n
virtual sensor unknown_count:%d\n
virtual sensor on:%d/%d/%d\n
virtual sensor off:%d/%d/%d\n
@@@@@@ reset side_bump_continued p[%.1f %.1f %.1f] str_p[%.1f %.1f %.1f] dist[%.1f] ang[%.1f]\n
@@@@@@set_side_bump_continued %d\n
@@@@@@ reset side_bump_continued by time\n
@mod_bump cont[%d] side_bmp[%d:%d] str_flg[%d] chk_cnt[%d %d] dur_cnt[%d] ign_dur_cnt[%d] ign_flag[%d] prv_bmp[%d] prv_ang[%.1f] chk_ang[%.1f %.1f] p[%.1f %.1f %.1f] str_p[%.1f %.1f %.1f] dist[%.1f] ang[%.1f]\n
[SEN_MOD] BOTT_FRONT %d\n
[SEN_MOD] BOTT_LEFT %d\n
[SEN_MOD] BOTT_RIGHT %d\n
[SEN_MOD] BOTT_dir latch %d\n
check_magnetic_gate sts %d m_p[%.1f %.1f] r_p[%.1f %.1f] d_p[%.1f %.1f],   %.1f %.1f\n
[STATUS.SM] valid_dock_pos=%d dock_pos=(%+6.1f,%+6.1f) dock_angle=%+6.1f station_type=%d\n
[STATUS.SM] time_count=%d bump_count=%d\n
fence_pose_array theta %f, rho %f, dist %f, dist_margin %f pose=(%+6.1f,%+6.1f %+6.1f,%+6.1f)\n
[Docking Candidate Station Front:-500,0 now:%3.0f %3.0f/Size:%d]\n
[Docking Candidate:<SIG CENTER>%3.0f %3.0f/Size:%d]\n
[Docking Candidate:<SIG LEFT>%3.0f %3.0f/Size:%d]\n
[Docking Candidate:<SIG RIGHT>%3.0f %3.0f/Size:%d]\n
[Docking Signal Setting Error - push!!]\n
[Check Dock Sig] dock sig wide %d\n
[Check Dock Sig] dock sig l:%d r:%d c:%d \n
[Check Dock Sig wo/map] set_homing_stop(HOMING_STOP_TRAN_DOCK) - now pose %3.0f %3.0f/Size:%d\n
[Check Dock Sig] set_homing_stop(HOMING_STOP_TRAN_DOCK) - now pose %3.0f %3.0f/Size:%d\n
[Check Dock Sig] set_homing_stop(HOMING_STOP_CHNG_DEST) -  latch!\n
[Check Dock Sig] set_homing_stop(HOMING_STOP_NONE_DONOT_FINAL_RT)\n
[Docking Candidate:<SIG Type %d>%3.0f %3.0f/Size:%d]\n
[Check Dock Sig] set_homing_stop(HOMING_STOP_CHNG_DEST)\n
[Check Dock Sig] set_homing_stop(HOMING_STOP_CHNG_DEST) -  latch!!\n
[fence] fnc_num %d\n
[fence] bl1_dt_step %d\n
[fence] d_margin=%+6.1f dist (%+6.1f, %+6.1f) f_rho %f r_rho %f diff_rho %f f_q %+6.1f r_q %+6.1f f_pose=(%+6.1f,%+6.1f %+6.1f,%+6.1f) r_pose=(%+6.1f,%+6.1f)\n
[fence]<%d,%d> d_margin=%+6.1f dist (%+6.1f, %+6.1f) f_rho %f r_rho %f diff_rho %f f_q %+6.1f r_q %+6.1f f_pose=(%+6.1f,%+6.1f %+6.1f,%+6.1f) r_pose=(%+6.1f,%+6.1f)\n
[fence]<%d> d_margin=%+6.1f dist (%+6.1f, %+6.1f) f_rho %f r_rho %f diff_rho %f f_q %+6.1f r_q %+6.1f f_pose=(%+6.1f,%+6.1f %+6.1f,%+6.1f) r_pose=(%+6.1f,%+6.1f)\n
[fence]<%d> linvel=%.1f d_margin=%+6.1f dist (%+6.1f, %+6.1f) f_rho %f r_rho %f diff_rho %f f_q %+6.1f r_q %+6.1f f_pose=(%+6.1f,%+6.1f %+6.1f,%+6.1f) r_pose=(%+6.1f,%+6.1f)\n
[fence]<%d> d_margin=%+6.1f dist (%+6.1f, %+6.1f) f_rho %f r_rho %f diff_rho %f f_q %+6.1f r_q %+6.1f r_dt_q [%+6.1f %+6.1f %+6.1f] f_pose=(%+6.1f,%+6.1f %+6.1f,%+6.1f) r_pose=(%+6.1f,%+6.1f)\n
[fence_NoDT]<%d> d_margin=%+6.1f dist (%+6.1f, %+6.1f) f_rho %f r_rho %f diff_rho %f f_q %+6.1f r_q %+6.1f r_dt_q [%+6.1f %+6.1f %+6.1f] f_pose=(%+6.1f,%+6.1f %+6.1f,%+6.1f) r_pose=(%+6.1f,%+6.1f)\n
[STATUS.SM] rotate_halo=%d\n
@@@@@@Set_back_climb\n
@@@@@@Set_back_climb latch:%d prvV %.1f vel %.1f\n
@@@@@@No set_climb latch:%d prvV %.1f vel %.1f\n
@@@@@@detected bottom [%d:%d:%d] cnt [%d]\n

 No ignore_back_climb %d %d\n

 set_back_climb_continued %d %d %d\n
[STATUS.SM] valid_dock_pos=false\n
[STATUS.SM] turetP [%.1f %.1f][%.1f %.1f] diffP [%.1f %.1f][%.1f %.1f] norm_diff [%.1f][%.1f] virtual_halo [%d]\n
[STATUS.SM] ON  ** station halo [%d:%d]\n
[STATUS.SM] OFF ** station halo [%d:%d]\n
[STATUS.SM] real_station_halo=%d virtual_station_halo=%d\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf3<void, mx_report, tsock&, tsock&, int>, boost::_bi::list4<boost::_bi::value<mx_report*>, boost::arg<1>, boost::arg<2>, boost::arg<3> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf2<void, mx_report, tsock&, int>, boost::_bi::list3<boost::_bi::value<mx_report*>, boost::arg<1>, boost::arg<2> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf2<int, mx_report, tsock&, unsigned char>, boost::_bi::list3<boost::_bi::value<mx_report*>, boost::arg<1>, boost::arg<2> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf3<int, mx_report, tsock&, unsigned char*, unsigned int>, boost::_bi::list4<boost::_bi::value<mx_report*>, boost::arg<1>, boost::arg<2>, boost::arg<3> > >]
%c %02x\n
%c %02x
Closing %s
already closed.\n
Creating %s
Opening %s (%d)
 * tsock::open_server_by_if() returns %d (%s)\n
report socket
[REPORT] Socket accepted: %s\n
Opening %s
@@@@
Fail to send_socket()\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
##### [mx_velocity_measurement] wheel_base_dist %.1f\n
w=%+6.1f curr=%+6.1f prev=%+6.1f freq=%5.2f\n
VM_BY_MICOM\n
VM_BY_WHEEL_VEL\n
VM_BY_ENCODER\n
%8d vel:    v=%+8.0f we=%+8.1f wg=%+8.1f)\n
%8d sum:    d=%+8.0f ae=%+8.1f ag=%+8.1f)\n
%8d abssum: d=%+8.0f ae=%+8.1f ag=%+8.1f)\n
V: %+6.1f W: %+6.1f V_C: %+6.1f W_C: %+6.1f ENC_L: %8d ENC_R: %8d\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, unsigned char*>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_localization, unsigned int>, boost::_bi::list2<boost::_bi::value<mx_localization*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_map_building, unsigned int>, boost::_bi::list2<boost::_bi::value<mx_map_building*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_report, unsigned int>, boost::_bi::list2<boost::_bi::value<mx_report*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, mx_map_building, const char*>, boost::_bi::list2<boost::_bi::value<mx_map_building*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, status_subsys, void*>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::arg<1> > >]
(%8ld)[STATUS    ] read_wcam_from_device() ==> %08X\n
[STATUS] Off WiLD camera
off camera
[STATUS] On  WiLD camera
on camera
##### [status_subsys] %.1f %.1f %.1f %.1f %.1f\n
%02d%02d%02d01
db/rvc/build_date
db/rvc/vision_ver
db/rvc/main_ver
db/rvc/sensor_ver
db/rvc/display_ver
db/rvc/model_nation
%02X%02X%02X%X%X
db/rvc/model_info
db/rvc/cleantool_info
db/rvc/repetition_info
[VERSION INFO] %d %d %d %d %d %s %d %d\n
db/rvc/accumulated_energy
/bin/rm -rf /opt/data/robot-network/*
%d %d %d %d\n
 wheel_motor cmd [%d] sts [%d]
### wheel_motor cmd [%d] sts [%d]\n
filename = %s\n
status thread
localization
map building
velocity measurement
dead reckoning
sensor modification
HW event processing
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
%s thread params:\n
thread_priority = %d\n
wait_start      = %d\n
sampling_time   = %d\n
sleep_time      = %d\n
thread_report   = %d\n
control_max_time= %d\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
#< * Resetting Gyro\n
   check count = %4d, req count = %4d, gyro angle = %+7.2f\r
\n * Done.\n
\n * Error!\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
 * Localization disabled.\n
 * Starting localization ... \n
 * Done.\n
 * Error! (timeout)\n
 * Starting localization (Phase 1)...
 * Starting localization (Phase 2)...
 * Starting localization (Phase 3)...\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
 * Stopping localization...\n
doit
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/execution/status_util/map_clearer.cpp
Map is not assigned!\n
     Map clear index = %d\r
doit
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/execution/status_util/map_resetter.cpp
     Map reset index = %d\n
     Map reset shift = (%+7.1f,%+7.1f,%+6.1f)\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
 * Resetting robot pose\n
     Before       (       x,       y,     q)\n
     pabo-pose  = (%+8.1f,%+8.1f,%+6.1f)\n
     arbo-pose  = (%+8.1f,%+8.1f,%+6.1f)\n
     slam-pose  = (%+8.1f,%+8.1f,%+6.1f)\n
     fused-pose = (%+8.1f,%+8.1f,%+6.1f)\n
\n     Resetting robot pose...
error!\n\n
done.\n\n
     After        (       x,       y,     q)\n
   %6d %+8.1f %+8.1f %+6.1f %+6.1f %+6.1f %+6.1f %+6.1f %+8.1f %+8.1f %+6.1f %+7.2f %8d %8d %+4d %+4d\n
## starting log at %s
## %6s %8s %8s %6s %6s %6s %6s %6s %8s %8s %6s %7s %8s %8s %4s %4s\n
lenc
renc
lpwm
rpwm
   %6d\t%8.2f\t%8.2f\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%d\t%8.2f\t%8.2f\t%d\t%8.2f\t%8.2f\t%8.2f\t%8.2f\t%8.2f\t%8.2f\t%8.2f\t%8.2f\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\t%8d\n
## %6s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\t%8s\n
upp_l
upp_f
upp_r
ir_1
ir_2
ir_3
ir_4
ir_5
ir_6
ir_7
ir_8
ir_9
ir_10
ir_11
ir_12
l_WF_s_st
l_WF_s_p_x
l_WF_s_p_yr_WF_s_st
r_WF_s_p_x
r_WF_s_p_y
ird_fl
ird_fr
ird_sl
ird_sr
ird_rl
ird_rr
dock_c_fl
dock_c_fr
dock_c_sl
dock_c_sr
dock_c_rl
dock_c_rr
dock_l_fl
dock_l_fr
dock_l_sl
dock_l_sr
dock_l_rl
dock_l_rr
dock_r_fl
dock_r_fr
dock_r_sl
dock_r_sr
dock_r_rl
dock_r_rr
dock_w_fl
dock_w_fr
dock_w_sl
dock_w_sr
dock_w_rl
dock_w_rr
dock_s_fl
dock_s_fr
dock_s_sl
dock_s_sr
dock_s_rl
dock_s_rr
:p<pH
Error : rvc_sensor_unprepare failed : %x\n
Error : rvc_sensor_destroy failed : %x\n
Error : rvc_sensor_create failed : %x\n
Error : rvc_sensor_set_resolution failed : %d\n
[WiLD] resolution set 320x240
[WiLD] resolution set 640x480
Error : rvc_sensor_prepare failed : %x\n
%s Open error!\n
/dev/i2c
[WCAM reg %02x] Write fail..-\n
[WCAM Bank2 reg %02x] Write fail..-\n
[WCAM Bank2 reg %02x] Read fail..-\n
[WCAM Bank2 reg %02x] different value expect=%02x, read=%02x\n
[WCAM Bank0 reg %02x] Write fail..-\n
[WCAM Bank0 reg %02x] Read fail..-\n
[WCAM Bank0 reg 02%x] different value expect=%02x, read=%02x\n
Error : ChangeCameraRegisterAE failed
\n[reg %d] Write fail..-\n
handler_run
get_input_buf
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(const char*, _IO_FILE*), boost::_bi::list2<boost::arg<1>, boost::_bi::value<_IO_FILE*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(_IO_FILE*), boost::_bi::list1<boost::_bi::value<_IO_FILE*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf0<bool, console>, boost::_bi::list1<boost::_bi::value<console*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, console>, boost::_bi::list1<boost::_bi::value<console*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, tserial, const char*>, boost::_bi::list2<boost::_bi::value<boost::shared_ptr<tserial> >, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, tsock, const char*>, boost::_bi::list2<boost::_bi::value<boost::shared_ptr<tsock> >, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, console, int>, boost::_bi::list2<boost::_bi::value<console*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf2<int, console, tserial&, unsigned char>, boost::_bi::list3<boost::_bi::value<console*>, boost::arg<1>, boost::arg<2> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf3<void, console, tsock&, tsock&, int>, boost::_bi::list4<boost::_bi::value<console*>, boost::arg<1>, boost::arg<2>, boost::arg<3> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf2<void, console, tsock&, int>, boost::_bi::list3<boost::_bi::value<console*>, boost::arg<1>, boost::arg<2> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf2<int, console, tsock&, unsigned char>, boost::_bi::list3<boost::_bi::value<console*>, boost::arg<1>, boost::arg<2> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, tsock, const char*>, boost::_bi::list2<boost::_bi::value<tsock*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, console, void*>, boost::_bi::list2<boost::_bi::value<console*>, boost::arg<1> > >]
FCA start
[%4d]$
error!\n * tsock::open_server_by_if() returns %d (%s)\n
remote console socket
[CONSOLE] Socket accepted: %s\n
[%8d] diff=%+7.2f, odometry=%+7.2f, gyro=%+7.2f, angle_sum=%+7.2f\n
count = %4d, time_diff = %4d ms, gyro angle = %+7.2f\r
%6d\r
basic_string::erase
\nCommand History: %d\n
 %4d  %s\n
mobility
device
Usage: thread <thread> <run|stop>\n
       <thread>: mobility, status, device\n
NXP debug override enabled.\n
NXP debug override disabled.\n
Set NXP debug override value %d.\n
USAGE: nxpdebug enable|disable\n
       nxpdebug <number>\n
Reset Task\n
Map Test\n
Reset Sector Map\n
Usage: delete <filename>\n
Deleting file '%s'...
error! (%d, %s)\n
Usage: writelogsig [<filename>]\n
Writing signal log to '%s' file\n
  %d records, %d bytes(mem), %d bytes(file)...
error! (can't open file)\n
Status(or signal) logging disabled!\n
  See configuration file's status__log\n
Resetting signal log...
error! (Still writing signal log!)\n
Status(or Signal) logging disabled!\n
Usage: writelog [<filename>]\n
Writing status log to '%s' file\n
Status logging disabled!\n
Resetting status log...
error! (Still writing log!)\n
Reset robot pose\n
  Before       (       x,       y,     q)\n
  pabo-pose  = (%+8.1f,%+8.1f,%+6.1f)\n
  arbo-pose  = (%+8.1f,%+8.1f,%+6.1f)\n
  slam-pose  = (%+8.1f,%+8.1f,%+6.1f)\n
  fused-pose = (%+8.1f,%+8.1f,%+6.1f)\n
\n  Resetting robot pose...
  After        (       x,       y,     q)\n
Reset Map\n
Usage: dump <filename>\n
Can't open file.(%s)\n
Dumping file '%s'.\n
Exiting...\n\n
Motor\n
Reserved\n
Gain\n
Kp=%d, Ki=%d, Kd=%d, Kff=%d, Kdz=%d\n
Kp=%d, Ki=%d, Kd=%d\n
Usage: gain <Kp> <Ki> <Kd> [<Kff> <Kdz>]\n
       gain {reset|r}\n
Current Gain: Kp=%d, Ki=%d, Kd=%d, Kff=%d, Kdz=%d\n
Do nothing. (Task already stopped!)\n
Stopping task...
done. (Task stopped)\n
Do nothing. (Task is already running!)\n
Running task in background...
Running task in foreground...
Press CTRL-C to stop task.\n
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/managing/console_subsys/console.cpp
before\n
after\n
Task stopped.\n
proxytest: console_proxy vector function call test.\n
console_proxy::set_loop_handler, for_each and boost::bind\n
console_proxy::set_loop_handler, for_each and bind2nd, mem_fun\n
console_proxy::init, for_each and boost::bind\n
console_proxy::init, for_each and bind2nd, mem_fun\n
Emergency Stop!!\n\n
%.2f seconds elapsed after program start.\n
Error: No begin time recorded!\n
There are %8lld total Kbytes of physical memory.\n
There are %8lld free  Kbytes of physical memory.\n
There are %8lld total Kbytes of virtual memory.\n
There are %8lld free  Kbytes of virtual memory.\n
CPU currently used: %5.2f percent.\n
CPU currently used by this process: %5.2f percent.\n
Type 'help' for usage.\n
Press CTRL-C to enter console.\n
\n\nCTRL-C pressed, exiting loop...\n\n
\n\nCTRL-C pressed, exiting task (1)...\n\n
\n\nCTRL-C pressed, exiting program...\n\n
\n\nCTRL-C pressed, exiting task (2)...\n\n
\n\n\n\n\n\n################################################################################\n#                                                                              #\n
# Welcome to Samsung MAX-RVC Socket Console                                    #\n
#   - Socket name: %-32s                            #\n
#   - Socket port: %5d                                                       #\n
#                                                                              #\n
################################################################################\n\n
Task in foreground (task only start),\n
press 'Ctrl-C' key to quit foreground task and enter console input mode.\n
** IMPOSSIBLE CASE! console disabled at start and task is not running.
Task in foreground,\n
Console in loop and task in foreground,\n
Console in loop,\n
press 'Ctrl-C' key to quit console loop and enter console input mode.\n
Task in background.\n
Use 'stop' command to quit background task.\n
Task is not running.\n
info
help
uptime
estop
looptest
proxytest
script
param
exit
history
config
dump
delete
threport
resetpose
resetgyro
resetlog
writelog
resetlogsig
writelogsig
resetmap
resetsector
maptest
resettask
commandtest
nxbcmd
nxbsts
nxpdebug
runloc
stoploc
findori
viewcmd
PGUP
PGDN
DOWN
PAD_HOME
PAD_END
PAD_ENTER
PAD_5
key = %02X  (%d -->
m_argc = %d\n
m_argv[%d] = "%s"\n
%s: command not found!\n
Opening %s (%s,%s,%d,%d)
error!\n * tserial::open() returns %d (%s)\n
remote console serial
enabled
disabled
\n[CONSOLE] Status:
 * stdio  console input : %s.\n
 * stdio  console output: %s.\n
 * serial console input : %s.\n
 * serial console output: %s.\n
 * socket console input : %s.\n
 * socket console output: %s.\n\n
\n\n\n\n\n\n################################################################################\n
# Welcome to Samsung MAX-RVC Serial Console                                    #\n
#   - Serial name: %-32s                            #\n
#   - Serial port: %-4s                                                        #\n
#   - serial baud: %-6s                                                      #\n
test 6: compare loop_handler and loop_handler2 performance.\n
loop_handler  loop test.\n
\n** USER BREAK **\n
loop_handler  : %8ld us\n
loop_handler2 loop test.\n
loop_handler2 : %8ld us\n
console thread
%+7.2f\n
Gyro Tuning\n
Test0, %d\n
Gyro Resetting\n
Gyro Test\n
Usage: gyro reset [{on|off}]\n
       gyro {cw|ccw} <turn>\n
       gyro {test|t}\n
0: NONE\n
3: MAX\n
4: SELECT AND GO\n
5: CREATE MAP\n
6: DOCKING\n
7: STOP\n
NONE\n
AUTO\n
SPOT\n
MAX\n
SELECT AND GO\n
CREATE MAP\n
DOCKING\n
STOP\n
nxp board command = (%d, 0x%02x)\n
Usage: nxbcmd <command> <option>\n
NXP board status = %d 0x%02x 0x%02x snd=%d goto=(%+6.0f,%+6.0f)\n
Status Sub-system forced NXP board status enabled.\n
Status Sub-system forced NXP board status disabled.\n
Usage: commandtest <command> [<option1> [<option2> [<sound> [x y]]]]\n
       commandtest enable|e\n
       commandtest disable|d\n
  <command>:\n
    0: IDLE\n
    1: AUTO\n
    2: SPOT\n
    3: MANUAL\n
    4: GOTO\n
    5: DEMO\n
    6: EXPO\n
    7: CALIBRATION\n
   38: SLAVE\n
  <option1>:\n
    format:  binary number (ex. 1, 10, 10101)\n
    default: 00001\n
  <option2>:\n
    format:  binary number (ex. 1, 11, 100)\n
    default: 111 (reset-gyro, reset-slam, reset-map)\n
  x y:\n
    goto mode goal position\n
Turn on suction motor.\n
Turn off suction motor.\n
Usage: suc on|off\n
On Side Brush\n
Off Side Brush\n
Usage: sb on|off\n
Set Drum Brush PWM\n
Usage: db <pwm>\n
# arbo help file                                                                \n\rCommands:                                                                       \n\r  ver (v)                              : print version                          \n\r  commandtest enable|disable (ct)      : enable/disable command test mode       \n\r  commandtest <command> <option> (ct)  : set command & option                   \n\r  config (conf)                        : print parameter                        \n\r  db <pwm>                             : drum brush motor                       \n\r  debug <num>                          : debug print on/off                     \n\r  delete <filename>                    : delete file                            \n\r  dump <filename>                      : dump text file                         \n\r  estop (e)                            : emergency stop                         \n\r  exit                                 : exit program                           \n\r  gain <Kp> <Ki> <Kd>                  : motor gain setting                     \n\r  gain reset                           : motor gain reset                       \n\r  gyro ccw|cw <turn> (gy)              : gyro tuning test                       \n\r  gyro reset [on|off] (gy r)           : gyro reset control                     \n\r  help (h)                             : print this screen                      \n\r  history                              : command line history                   \n\r  looptest                             : console loop performance test          \n\r  motion on|off (mo)                   : on/off motion controller               \n\r  motion wheel <motion command> (mo w) : run wheel motion command               \n\r  motor (m)                            : reserved                               \n\r  nxbcmd <nxp mode> <nxp option> (nc)  : set NXP board command                  \n\r  nxpdebug enable|disable              : enable/disable NXP debug command       \n\r  nxpdebug <number>                    : set NXP debug command                  \n\r  proxytest                            : console proxy test                     \n\r  report [<sleep>] (r)                 : report status                          \n\r  resetgyro (rg)                       : reset gyro                             \n\r  resetlog (rl)                        : reset status   log                     \n\r  resetmap (rm)                        : reset map                              \n\r  resetpose (rp)                       : reset robot pose                       \n\r  resettask (rt)                       : reset task and task's FSM              \n\r  run [&]                              : run task subsystem                     \n\r  runloc                               : run localization                       \n\r  sb on|off                            : side brush motor                       \n\r  script <filename> (sc)               : run script file                        \n\r  stop                                 : stop task subsystem                    \n\r  stoploc                              : stop localization                      \n\r  suc on|off                           : suction motor                          \n\r  test [0..9] (t [0..9])               : test 0..9                              \n\r  threport (tr)                        : report thread                          \n\r  uptime                               : uptime                                 \n\r  writelog [<filename>] (wl)           : write status log to file               \n\r  findori (fo)                         : find ceiling angle                     \n\r  viewcmd (vc)                         : view command                           \n\r                                                                                \n\r  <motion command>\t                                                            \n\r    stop [prof_dist req_v_e req_w_e req_time [fc_time]]                         \n\r    move-pose x_t y_t th_t [v_c [v_t w_max dir [req_d_e req_th_e
 req_time]]]    \n\r    rotate th_t [w_max dir r_dir [req_th_e req_time]]                           \n\r    timed-rotate th_t ctime [dir r_dir [req_th_e req_time]]                     \n\r    move-fw l [v_c [w_max dir [req_d_e req_th_e req_time]]]                     \n\r    move-bw l [v_c [w_max dir [req_d_e req_th_e req_time]]]                     \n\r    timed-move-fw l ctime [w_max dir [req_d_e req_th_e req_time]]               \n\r    timed-move-bw l ctime [w_max dir [req_d_e req_th_e req_time]]               \n\r    reach-line x_l y_l th_l [l_l [v_c [v_t w_max dir r_dir [req_d_e req_time]]]]\n\r    move-to x_t y_t [v_c [v_t w_max dir r_dir [req_d_e req_time]]]              \n\r    turn-to x_t y_t th_t [v_t w_max dir r_dir [req_d_e req_th_e req_time]]      \n\r    follow-circle x_c y_c r [d_l [v_t [w_max dir [req_l_e req_th fc_time]]]]    \n\r    follow-line x_l y_l th_l [d_l [v_c v_t [w_max dir [req_l_e req_d fc_time]]]]\n\r    follow-wall l w_dir [v_t [w_max dir [mode smask sid]]]                      \n\r#    follow-wall-ir l w_dir [v_t [w_max dir]]                                   \n\r#    follow-wall-sonar l w_dir [v_t [w_max dir]]                                \n\r#    follow-beacon [v_c [v_t [w_max dir]]]                                      \n\r    ctl-speed v [w [fc_time]]                                                   \n\r    ctl-motor on|off|clear [mc_time]                                            \n\r#  motor   wheel|left-arm|right-arm|head-pan|head-tilt <cmd> <args>             \n\r#  report  all                                                                  \n\r#  report  sensor [-s]                                                          \n\r#  report  motion all|wheel|joint [left-arm|right-arm|head-pan|head-tilt]       \n\r#  report  motor  all|wheel|joint [-s]                                          \n\r#  chargen [sleep]                                                              \n\r#  set loc <x> <y> <th>, reset loc                                              \n\r#  batt [sleep]                                                                 \n\r#  beacon [sleep]                                                               \n\r#  dock [modObs], docklong [modObs] [chargeTime]                                \n\r#  uptime [-r] [sleep]                                                          \n\r#  test0, test1                                                                 \n\r
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(const char*, _IO_FILE*), boost::_bi::list2<boost::arg<1>, boost::_bi::value<_IO_FILE*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(_IO_FILE*), boost::_bi::list1<boost::_bi::value<_IO_FILE*> > >]
%s changed to %d\n
Usage: debug <number>\n
  %3d : Toggle '%s' flag\n
device.pibo_serial.verbose
device.device__pibo__rcvpkt__report
device.device__pibo__sndpkt__report
device.pibo_serial.print_time
device.device__pibo__rcvpkt__time_print
device.pibo_serial.log_packet
device.nxbo_serial.verbose
device.device__nxbo__rcvpkt__report
device.device__nxbo__sndpkt__report
device.nxbo_serial.print_time
device.device__nxbo__rcvpkt__time_print
device.nxbo_serial.log_packet
device.nxbo_serial.print_chksum_mismatch
status.print_upp_dist_sensor
status.print_ir
status.print_wheel
status.localization.slip.print
status.localization.cvslam.grabber.display_image
status.localization.cvslam.print_message
status.localization.cvslam.print_robot_mean
status.localization.print_coordinate
status.velocity_measurement.print_method
status.velocity_measurement.print_velocity
status.velocity_measurement.print_enc_vel
status.dead_reckoning.print_method
status.dead_reckoning.print_coordinate
status.map_building.print_update_pose
status.map_building.print_update_sensor
status.map_building.print_send_thread
status.sensor_modification.print_general
status.hwevent_processing.print_sound
status.hwevent_processing.motor_gain
SQA.status.send_posture
SQA.status.send_motion
task.nav.print_clean
task.nav.print_command
task.nav.print_tmb
task.nav.sc.print_general
task.nav.sc.print_state
task.nav.sc.print_action
task.nav.sc.print_motion
task.nav.sc.print_input_result
task.nav.sc.clean_completed
task.nav.sc.clean_error_code
task.autoplan.print_general
task.autoplan.print_state
task.autoplan.print_aligner
task.autoplan.print_sector_clean
task.autoplan.print_smooth_turn
task.autoplan.print_follow_wall
task.autoplan.print_thread_sync
task.autoplan.print_divide_district
task.gotoplan.print_general
task.gotoplan.print_thread_sync
task.pathplan.print_general
task.pathplan.print_data
task.pathplan.print_time
device.print_sound
device.sensor_res.olp.print_ol
device.sensor_res.olp.caibration_ol
device.sensor_res.olp.caibration_wf
device.sensor_res.olp.caibration_total
SQA.AUTOPLAN
SQA.GOTOPLAN
SQA.FSM
SYSOUTLEVEL
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(const char*, _IO_FILE*), boost::_bi::list2<boost::arg<1>, boost::_bi::value<_IO_FILE*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(_IO_FILE*), boost::_bi::list1<boost::_bi::value<_IO_FILE*> > >]
parse
Usage: motion wheel <motion command>\n
 %c P=(%+8.1f,%+8.1f,%+6.1f), V,W=(%+6.1f,%+6.1f), T=%6d,%3s, %-10s\r
/-\\|
\n    Done.\n
Usage: motion wheel\n
  %s\n\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(const char*, _IO_FILE*), boost::_bi::list2<boost::arg<1>, boost::_bi::value<_IO_FILE*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(_IO_FILE*), boost::_bi::list1<boost::_bi::value<_IO_FILE*> > >]
Usage: report <binary-number>|<token> [<sleep-time>]\n
  <token>: all, pose, vel, sum, abs_sum, board, motor, sensor, ui,\n
           wheel, ir, bott, bump, susp, gyro, acc, stuck, etc, upp, slip\n
           drag, dock, rmc_dir, cmd\n
  <sleep-time>:\n
    default: 20 ms\n
abs_sum
sensor
bott
susp
drag
dock
rmc_dir
Pose
odm.=(%+6.0f %+6.0f %+6.1f),
slam=(%+6.0f %+6.0f %+6.1f),
map_pose=(%+6.0f %+6.0f %+6.1f),
last_auto=(%+6.0f %+6.0f %+6.1f),
Homing=(%+6.0f %+6.0f %+6.1f)\n
Report ,%4d\n
%-12s: Command=(%+6.1f %+6.1f) Status=(%+6.1f %+6.1f %+6.1f)\n
Velocity
%4d
%-12s: dist=%+8.1f  enc_ang=%+8.1f  gyro_ang=%+8.1f\n
Abs. Sum
\tid: %03d FL: %d%d%d%d%d%d FR: %d%d%d%d%d%d SL: %d%d%d%d%d%d SR: %d%d%d%d%d%d RL: %d%d%d%d%d%d RR: %d%d%d%d%d%d %02d\n
%-12s: [g:%d s:%d m:%d]\n
reset result
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(const char*, _IO_FILE*), boost::_bi::list2<boost::arg<1>, boost::_bi::value<_IO_FILE*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(_IO_FILE*), boost::_bi::list1<boost::_bi::value<_IO_FILE*> > >]
Usage: script <filename>\n
(%4d) Processing wheel motion (%s).\n
Script interrupted.\n
Script elapsed time: %0.2f ms\n
Run script file. (%s)\n
Writing log file (%s) ...
error! (Can't open file)\n
##**PPw
:p<pH\bI\fy\b
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(const char*, _IO_FILE*), boost::_bi::list2<boost::arg<1>, boost::_bi::value<_IO_FILE*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(_IO_FILE*), boost::_bi::list1<boost::_bi::value<_IO_FILE*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
test 4:\n
cwd = "%s"\n
SPRINTF macro test (%d, %d, %d).\n
SPUTS macro test.\n
ARBO_MAX_BUF_LEN = %d\n
point_set.size() = %d\n
Usage: test <number>\n
test 0: test_main()\n
get_address() returns: 0x%08X\n
test 1:\n
** MAX board command report:\n
\n** MAX motor command report:\n
\n** MAX sensor command report:\n
\n** MAX ui command report:\n
\n** MAX board status report:\n
\n** MAX motor status report:\n
\n** MAX sensor status report:\n
\n** MAX ui status report:\n
test 2:\n
result3.m_clean_completed = %d\n
result4.m_clean_completed = %d\n
test 5: print OS build number, SW version, SVN revision, build date.\n
OS build number : %ld\n
SW version      : %02X\n
SCM revision    : %s\n
Build data&time : %s\n
test 6: planning_reason test.\n
id=%s sensor_id=%s fw_info=%s\n
test 7:\n
test 10: sound test\n
mm_sound_volume_get_value(system) 0x%x\n
==> current vol(system) : %u\n
wrong sound id : %d\n
wrong volume level(0~15):%d\n
==> changed vol(system): %u\n
wrong arg\n
  1: play test with loop & sleep\n
\t$ t 10 1 [sound id]\n
\t$ t 10 1 [sound id] [loop count]\n
\t$ t 10 1 [sound id] [loop count] [sleep time(ms)]\n
  2: play test with volume(nx: 0~4,tz:0~15)\n
\t$ t 10 2 [sound id]\n
\t$ t 10 2 [sound id] [volume]\n
sound type(0:Beep,1:Mute,2:W,3:M) = %d\n
test 11:\n
test_char <= 0 (%d)\n
InputBase::Print()\n
InputDerived0::Print() %s\n
InputDerived1::Print() %s\n
OutputBase::Print()\n
OutputDerived0::Print() %s\n
OutputDerived1::Print() %s\n
Derived0::Call() %s \n
Derived1::Call() %s \n
 t 13 [map %d] [rep %d] [data %d] [to.i %d] [to.j %d]\n
 t 13 [map] [rep] [data] [to.i] [to.j]\n
 \t map : 0 = global map(default) else local map\n
 \t rep : 1 = report , 2 = get_data, 3 = set_data\n
 \t dat : 0 = CELL_BIT_ROBOT_PASSED\n
 \t       1 = CELL_BIT_REAL_WALL\n
 \t       2 = CELL_BIT_BUMP\n
 \t       3 = CELL_BIT_UPPERSTUCK\n
 \t       4 = CELL_BIT_CLIMB\n
 \t       5 = CELL_BIT_STATION\n
 \t       6 = CELL_BIT_DANGEROUS_POINT\n
 \t       7 = CELL_BIT_SLIP\n
 \t       8 = CELL_BIT_WHEEL\n
 \t       9 = CELL_BIT_LIFT\n
 \t      10 = CELL_BIT_CLIFF\n
 \t      11 = CELL_BIT_DRUMB\n
 \t      12 = CELL_BIT_SIDEB\n
 \t      13 = CELL_BIT_MAGNETIC\n
 \t      14 = CELL_BIT_HALO\n
 \t      15 = CELL_BIT_GATE\n
 \t (%d,%d) = 0x%X\n
 \t (%d,%d) = 0x%X(0x%X)\n
CPU load test\n
Sum = %f\n
elapsed time = %d us\n
sizeof(NavigationData)                = %d\n
sizeof(SensorData)                    = %d\n
sizeof(BoardData)                     = %d\n
sizeof(ReactiveMotion)                = %d\n
sizeof(Robot2PC_Cell_Arr_Data)        = %d\n
sizeof(Robot2PC_Cell_Reset)           = %d\n
sizeof(Robot2PC_Coord_Info)           = %d\n
sizeof(Robot2PC_Etc_Data)             = %d\n
sizeof(Robot2PC_Via_New)              = %d\n
sizeof(Robot2PC_Via_Pos)              = %d\n
sizeof(Robot2PC_Tmp_Via_New)          = %d\n
sizeof(Robot2PC_Tmp_Via_Pos)          = %d\n
sizeof(Robot2PC_Feature_List_New)     = %d\n
sizeof(Robot2PC_Feature_List_Elem)    = %d\n
sizeof(Robot2PC_Boundary_Area_New)    = %d\n
sizeof(Robot2PC_Boundary_Area_Vertex) = %d\n
sizeof(Robot2PC_Time)                 = %d\n
sizeof(Robot2PC_Navigation_Data)      = %d\n
sizeof(Robot2PC_Sensor_Data)          = %d\n
sizeof(Robot2PC_Board_Data)           = %d\n
sizeof(Robot2PC_Reactive_Motion)      = %d\n
ACM test\n
sts = %d\n
cat /opt/data/robot-network/files/clean.txt
ls -al /opt/data/robot-network/files/
input stauts\n
0: SLAM_PAUSE\n
1: Re-Localization Start\n
2: Re-Localization Continue\n
3: GET_RESULT\n
4: Localization\n
5: SET_KIDNAP_POSE\n
6: GET_TOTAL_LM\n
SLAM_PAUSE\n
Re-Localization Start\n
Re-Localization Continue\n
GET_RESULT = %d (0: Fail, 1: Process, 2: Success)\n
SLAM_AGAIN\n
SET_KIDNAP_POSE\n
GET_TOTAL_LM = %d\n
Global Map Update Map Size = %d\n
(%+3d,%+3d) %08X\n
Encoder sum : left = %10lld, right = %10lld\n
Enable  ceiling camera : t 21 1\n
Disable ceiling camera : t 21 0\n
Read  ceiling camera register : t 22 <bank> <addr>\n
Write ceiling camera register : t 22 <bank> <addr> <value>\n
Invalid arg[2] = %s\n
Invalid arg[3] = %s\n
Invalid arg[4] = %s\n
/dev/i2c-1
ioctl() error!\n
\n- Write fail.. -\n
\n- Read fail.. -\n
  0x%02X:0x%02X = 0x%02X\n
timespec = {%d, %d}, timeval = {%d, %d}\n
Write parameter to '%s'\n
max_test.conf
read target reg\n
test 26 [channel(0,1)] [bank(0,1,2)] [reg_addr(hex)]\n
ch (0: ceiling, 1: wild)\n
\n- bank Write fail.. -\n
\n- reg addr Write fail.. -\n\n
\n- Read fail.. -\n\n
CH[%d] BANK[%d] REG[%02X]= %02X\n
test 22: shutter operation(0:open, 1:close)\n
 t 22 [0 or 1]\n
 shutter close\n
 shutter open\n
test 28: forced_cleancomplete\n
test 8: singleton_holder partial specialization test.\n
test8_1::print()\n
singleton_holder<typename singleton_type>
test8_2::print()\n
singleton_holder<typename singleton_type, int size = %d>\n
test8_3::print()\n
test 12:\n
WiLD Camera setting : t 25 <cmd>\n
0: 1.2ms x2\n
1: 3.43ms x2\n
2: 7.65ms x2\n
3: 10.01ms x2\n
4: 14.58ms x2\n
5: 14.58ms x3\n
6: AE\n
7: default\n
8: read file\n
9: read inttime, g/gain, d/gain\n
/opt/app_rw/test_poa030r.dat
%02X%02X%[^\n]s
\n read file\n
%02X %02X\n
[%d] %02X %02X\n
%0.1fms, x%d(%02X), x%0.1f\n
test 9:\n
--encoder difference test on overflow range--\n
ldiff = %d, rdiff = %d\n
--bit shift test--\n
_sbitset = %08X  type=%d  dir=%d\n
test 3:\n
test 29: writing to eeprom manually\n
ex) t 29 [optX] [optY] [principal_pt_X] [principal_pt_Y]\n
optXY: [%f %f], principal_pt_XY: [%f %f] writing.. \n
wrong Input\n
B c0
s2R"
b$C4
S6r&
x@\ba
P\n3:
<`\fA
>2.Q
P%@Fpg`
RwbVr
ftGd$T
Wfvv
F4VL
DXeH
uJTZ7j
&|\ald\\EL
n6~UNt^
/mnt/nand/aui/list_crc
Fail to fseek()\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_auto_planning, int>, boost::_bi::list2<boost::_bi::value<mx_auto_planning*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_test_planning, int>, boost::_bi::list2<boost::_bi::value<mx_test_planning*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_fsm::fsm_nav, int>, boost::_bi::list2<boost::_bi::value<mx_fsm::fsm_nav*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_goto_planning, int>, boost::_bi::list2<boost::_bi::value<mx_goto_planning*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
[ROTATE_POS]     Forced rotate direction : %+d -> %+d (%+6.1f,%+7.1f)\n
[ROTATE_POS_DIR] Forced rotate direction : %+d -> %+d (%+6.1f,%+7.1f)\n
[ROTATE_ANG_DIR] Forced rotate direction : %+d -> %+d (%+6.1f,%+7.1f)\n
MOVETO_PASS
MOVETO_STOP
MOVETO_BACK
MOVETO_RT_BEGIN
MOVETO_RT_END
MOVETO_VIA
ROTATE_POS
ROTATE_POS_DIR
ROTATE_ANG_DIR
FOLLOWCIRCLE
FOLLOWCIRCLE_RT
FOLLOWLINE
FOLLOWLINE_RT_BEGIN
FOLLOWLINE_RT_END
FOLLOWLINE_PASS
FOLLOWLINE_STOP
FOLLOWLINE_VIA
FOLLOWLINE_TRANS
FOLLOWWALL
FOLLOWWALL_STOP
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = std::pointer_to_unary_function<const char*, int>]
[%5d %s] entry\n

[%5d %s] exit (%6ld ms)\n
\n determine_sensor_action_helper : emc_turn bothhalo\n
\n determine_sensor_action_helper : emc_turn detectir\n
\n determine_sensor_action_helper : narrow_pass \n
[SD]Trem:%5.3f V_in:%5.3f V_cur:%5.3f \n
[RTN]Trem:%5.3f V_in:%5.3f V_cur:%5.3f \n
 P=(%+8.1f,%+8.1f,%+6.1f), V,W=(%+6.1f,%+6.1f), T=%6d,%3s, %-10s\r
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
(%8ld)[FSM.GYRO] Reset stop time\n
(%8ld)[FSM.GYRO] Stop triggerd after %ld ms\n
st_c_a_none
(%8ld)[FSM.MOTION] motion NONE\n
st_c_a_stop
st_c_a_stop_for_fca
st_c_a_moveto
st_c_a_rotate
st_c_a_followcircle
st_c_a_followline
st_c_a_followwall
 * FOLLOWWALL_STOP: FW_COND=(%s)\n
st_c_a_sensor_stop
 * Sensor stop Reason: %s\n
st_c_a_sensor_stopandcheck
 * Sensor stopandcheck Reason: %s\n
st_c_a_sensor_back
 * Sensor back Reason: %s\n
st_c_a_sensor_stopandback
 * Sensor stopandback Reason: %s\n
st_c_a_sensor_approach_obs
 * Sensor approach_obs Reason: %s\n
st_c_a_sensor_stopandcheckandback
 * Sensor stopandcheckandback Reason: %s\n
(%8ld)[FSM.MOTION] Timeout in stop_for_fca! (%ld ms >= %d ms)\n
(%8ld)[FSM.STOP_FOR_FCA] Stopped for %ld ms\n
(%8ld)[FSM.MOTION] Timeout in none! (%ld ms >= %d ms)\n
(%8ld)[FSM.MOTION] Timeout in stop! (%ld ms >= %d ms)\n
(%8ld)[FSM.STOP(gyro)] Stopped for %ld ms\n
(%8ld)[FSM.MOTION] Timeout in sensor stop! (%ld ms >= %d ms)\n
(%8ld)[FSM.SENSOR_STOP] Stopped for %ld ms\n
(%8ld)[FSM.MOTION] Timeout in sensor stopandcheck! (%ld ms >= %d ms)\n
(%8ld)[FSM.SENSOR_STOPANDCHECK] False positive: %s\n
(%8ld)[FSM.SENSOR_STOPANDCHECK] Confirm: %s\n
(%8ld)[FSM.MOTION] Timeout in sensor back! (%ld ms >= %d ms)\n
detect virtual_rear\n
(%8ld)[FSM.MOTION] Timeout in sensor stopandback! (%ld ms >= %d ms)\n
(%8ld)[FSM.MOTION] Timeout in sensor stopandcheckandback! (%ld ms >= %d ms)\n
(%8ld)[FSM.SENSOR_STOPANDCHECKANDBACK] False positive: %s\n
(%8ld)[FSM.SENSOR_STOPANDCHECKANDBACK] Confirm: %s\n
(%8ld)[FSM.MOTION] Timeout in sensor approach_obs! (%ld ms >= %d ms)\n
(%8ld)[FSM.SENSOR_APPROACH_OBS] sensor_action:: STOP Confirm: %s\n
(%8ld)[FSM.SENSOR_APPROACH_OBS] sensor_action:: STOPANDCHECK Confirm: %s\n
(%8ld)[FSM.SENSOR_APPROACH_OBS] sensor_action:: BACK Confirm: %s\n
(%8ld)[FSM.SENSOR_APPROACH_OBS] sensor_action:: STOPANDBACK Confirm: %s\n
[FSM.SENSOR_APPROACH_OBS] EMC_STOP!!\n
(%8ld)[FSM.SENSOR_APPROACH_OBS] False positive: %s\n
(%8ld)[FSM.SENSOR_APPROACH_OBS] MAKE APPROACH OBS MOTION\n
(%8ld)[FSM.APPROACH_OBS] set gyro stop duration= %d\n
(%8ld)[FSM.SENSOR_APPROACH_OBS] SOFT_BUMP MOTION\n
(%8ld)[FSM.SENSOR_APPROACH_OBS] NO SOFT_BUMP MOTION\n
(%8ld)[RMC.FSM.CONTROL.ACT.ROTATE] Timeout in rotate! (%ld ms >= %d ms)\n
action_step = %d\n
[rotate_halo:%d rotate_side_halo:%d turn_angle:%3.1f]\n
detect back_climb #0\n
[emc turn situation:%d %d %d]\n
[general turn situation:%d %d %d]\n
detect side_rotate_halo:%d\n
\nLEFT_ROTATE_HALO : DIR_CW\n
\nRIGHT_ROTATE_HALO : DIR_CCW\n
m_action_step_backward_empty_count = %d\n
(%8ld)[RMC.FSM.CONTROL.ACT.ROTATE.BACKWARD] Timeout in rotate(in backward)! (%ld ms >= %d ms)\n
[backward turn situation:%d %d]\n
[backward stop turn situation:%d %d]\n
(%8ld)[RMC.FSM.CONTROL.ACT.ROTATE] forced rotate! (%ld ms >= %d ms)\n
(%8ld)[FSM.MOTION] Timeout in followcircle! (%ld ms >= %d ms)\n
(%8ld)[FSM.MOTION] Timeout in followline! (%ld ms >= %d ms)\n
[FSM_C_A] get_homing_stop type %d\n
(%8ld)[FSM.MOTION] Timeout in moveto! (%ld ms >= %d ms)\n
Invalid returntonomal condition in moveto!\n
 * FOLLOW WALL STOP : upper  \n
 * FOLLOW WALL STOP : lower  \n
 * FOLLOW WALL STOP : left  \n
 * FOLLOW WALL STOP : right  \n
 * FOLLOW WALL STOP : ccw_bound  \n
 * FOLLOW WALL STOP : cw_bound  \n
(%8ld)[FSM.MOTION] Timeout in followwall(followwallstop)! (%ld ms >= %d ms)\n
(%8ld)[FSM.MOTION] Timeout in followwall(stop)! (%ld ms >= %d ms)\n
 * FOLLOWWALL_STOP: fw_result=%s\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
st_c_a_parse
st_c_a_p_exit
st_c_a_p_postproc
st_c_a_p_do
[do_parse RM_ADV_INFO:AUTO] id: %d, time: %d, corner_count: %d, cell_size: %d, short_dist_flag: %d\n
(%8ld)[FSM.CONTROL] Auto mode completed(CLEAN_END) acm %d after %ld ms\n
(%8ld)[FSM.CONTROL] Auto mode completed(for Double ZigZag) after %ld ms\n
(%8ld)[FSM.CONTROL] Auto mode completed(ERR_ESCAPE) after %ld ms\n
 * %s\n
(%8ld)[FSM.CONTROL] Goto mode completed(FAIL) after %ld ms\n
(%8ld)[FSM.CONTROL] Goto mode completed(NEAR) after %ld ms\n
(%8ld)[FSM.CONTROL] Goto mode completed(COMPLETE) after %ld ms\n
(%8ld)[FSM.CONTROL] Goto mode completed(SENSOR) after %ld ms\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
[FSM.MOTION] Invalid motion! (fsm_motion::build_wheel_motion_cmd returns %d)\n
st_c_act
ACTION GO modification!\n
ACTION GOSTOP modification!\n
(%8ld)[FSM.MOTION] Via. list empty!\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
B cen 0:%5.0f %5.0f %5.0f\n
 cen 1:%5.0f %5.0f %5.0f\n
cur:%5.0f %5.0f %5.0f , cen 0 : %5.0f %5.0f %5.0f \n
cur:%5.0f %5.0f %5.0f , cen 3 : %5.0f %5.0f %5.0f \n
 cur:%5.0f %5.0f %5.0f , cen 1: %5.0f %5.0f %5.0f \n
cur:%5.0f %5.0f %5.0f , cen 2: %5.0f %5.0f %5.0f \n
------ 1point (x:%5.0f,y:%5.0f) (x2:%5.0f,y2:%5.0f) deg : cur:%5.0f %5.0f \n
st_c_a_t_init
st_c_a_t_followwall
st_c_a_t_exception
st_c_a_dust
st_c_a_test
st_c_a_dt_mtwocircle
st_dt_muturn
st_dt_muturn start \n
st_dt_muturn end \n
st_c_a_dt_meight
st_c_a_dt_mgoback
in st_c_a_dt_mgoback \n
out st_c_a_dt_mgoback \n
st_c_a_dt_init
st_c_a_dt_msidetwocircle
---------------- react in st_c_a_dust ----------------\n
(%8ld)[st_c_exception.msidetwocircle] Timeout in sidetwocircle (%ld ms >= %d ms)\n
----------- Transit To Doplan (BUMP,F-IR) ------------\n
---------------- back 60 ----------------\n
---------------- go 100----------------\n
---------------- case3 transit st_c_plan ----------------\n
transit good \n
goto case8 \n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
st_calibration
camcalib_status = %d\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
st_calibration_front
camcalib_status_front = %d\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
vector<bool>::_M_range_check
st_control
START align angle, check_dist : %.3f\n
FCA result : success! err = %d\n
FCA result : fail! err = %d\n
FCA result[%d-%d]: low accuracy!! accu = %0.2f\n
FCA result : fail! - find ceiling angle over %d times!\n
 * stop completed after %ld ms.\n
 * ctl-motor-off completed after %ld ms.\n
(%8ld)[FSM.CONTROL] ctl-motor-off timeout %ld ms. (too long! >= %d)\n
st_c_stop
st_c_init
 * AP Input: %s\n
(%8ld) %s >
(%8ld)[FSM.PLAN] IN:  %s\n
                          %s\n
(%8ld)[FSM.PLAN] Send signal(start) to auto planning (%ld ms)\n
(%8ld)[FSM.PLAN] Auto planning is NOT waiting signal(start)! (%ld ms)\n
(%8ld)[FSM.PLAN] BUT auto planning is waiting signal(completed! (%ld ms)\n
(%8ld)[FSM.PLAN] Send signal(completed) to auto planning (%ld ms)\n
 * GP Input: %s\n
(%8ld)[FSM.PLAN] Send signal(start) to goto planning (%ld ms)\n
(%8ld)[FSM.PLAN] Goto planning is NOT waiting signal(start)! (%ld ms)\n
(%8ld)[FSM.PLAN] BUT goto planning is waiting signal(completed)! (%ld ms)\n
(%8ld)[FSM.PLAN] Send signal(completed) to goto planning (%ld ms)\n
st_c_plan
(%8ld)[FSM.CONTROL] Auto mode exit after %ld ms [LastPose(x,y,q): (%5.3f, %5.3f,%5.3f)] [Error: %d %d]\n
(%8ld)[FSM.CONTROL] Goto mode exit(FIND_PATH) after %ld ms\n
(%8ld)[FSM.CONTROL] Goto mode exit(FAIL) after %ld ms\n
(%8ld)[FSM.CONTROL] Goto mode exit(NEAR) after %ld ms\n
(%8ld)[FSM.CONTROL] Goto mode exit(COMPLETE) after %ld ms\n
(%8ld)[FSM.CONTROL] Goto mode exit(SENSOR) after %ld ms\n
(%8ld)[FSM.CONTROL] Goto mode exit(!INVALID!) after %ld ms\n
vector<bool>::_M_fill_insert
rotate:%d, sensor:%d, turn_angle:%3.1f curr_w:%3.1f\n
 * ctl-motor-on completed after %ld ms.\n
(%8ld)[FSM.CONTROL] ctl-motor-on timeout %ld ms. (too long! >= %d)\n
use ceiling angle\n
don't use ceiling angle\n
(%8ld)[FSM.CONTROL] Find Ceiling Angle init\n
(%8ld)[FSM.CONTROL] AUTO PLANNING INIT\n
           %s %s\n
 double zigzag=%d, double zigzag_sub=%d\n
           reset_gyro=%d reset_slam=%d reset_map=%d reset_planner=%d\n
(%8ld)[FSM.CONTROL] GOTO PLANNING INIT\n
           REASON=%s\n
           reset_gyro=%d reset_slam=%d reset_map=%d opt1=%d opt2=%d opt3=%d\n
 * auto-planning completed after %ld ms.\n
(%8ld)[FSM.PLAN] Send signal(completed) to auto-planning (%ld ms)\n
 * AP Result: %s\n
(%8ld)[FSM.PLAN] Auto planning completed after %ld ms.\n
(%8ld)[FSM.PLAN] OUT: %s\n
(%8ld)[FSM.PLAN] Auto planning timeout! (%ld ms)\n
 * goto-planning completed after %ld ms.\n
(%8ld)[FSM.PLAN] Send signal(completed) to goto-planning (%ld ms)\n
 * GP Result: %s\n
(%8ld)[FSM.PLAN] Goto planning completed after %ld ms.\n
(%8ld)[FSM.PLAN] Goto planning timeout! (%ld ms)\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
crc true
crc false
st_crc::st_crc getRtn:%d \n
************ crc DOING!
************ crc FAIL!
************ crc SUCCESS!
- crc react! \n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
 >> [precheck_wf_direction] chk wf dir %1.0f, mch_cnt: %d, wf_cnt:[%d,%d], excp_cnt: %d, dur_cnt: %d
 >> @@@exception flag ON
 >> [decide_wf_direction] sen: %s, target_dir: %.2f
 >> keep the previous wf direction
 >> IR: in HANDLE_RIGHT-> LEFT_WALL
 >> IR: not in HANDLE_LEFT-> RIGHT_WALL
 >> IR: LEFT WALL #1
 >> IR: RIGHT WALL #1
 >> IR: LEFT WALL #2
 >> not IR: in HANDLE_RIGHT-> LEFT_WALL
 >> not IR: in HANDLE_RIGHT-> RIGHT_WALL
 >> target_dir: %.2f RIGHT WALLL
 >> target_dir: %.2f LEFT WALLL
 >> default dir is LEFT WALL, target_dir: %.2f
\n >> [motion_ctl_speed] slow motion:, v = %.2f, w = %.2f\n
\n >> [motion_ctl_speed] motion:, v = %.2f, w = %.2f\n
bitset::set
[Docking] Mode: %s -> %s, WF_motion_type: %s\n
SEEKING
[Docking] Mode: %s -> %s\n
 >> [Motion_to_Dock]
 >> Center : %d, Safe : %d, Left : %d, Right : %d, Wide : %d\n
 >> center %d: false
 >> center %d: true
 >> sts: %s, target_dir: %.2f, search_sig: %d
 >> LEFT_WALL_FINISH motion
 >> RIGHT_WALL_FINISH motion
 >> ir_wf_finish_motion_cnt = %d
 >> in_rt_opp_stn_cnt = %d, w_rt_opp_stn = %.3f
 >> finish HANDLE_OPPOSITE_STATION
 >> Bump [%d:%d], r_ir - l_ir= %d
 >> center_bump_motion_cnt = %d
 >> Backward
 >> Rotation
 >> Arc
 >> safe_motion_cnt = %d, w_safe = %.2f
 >> safe rotate
 >> safe end
 >> safe found center
 >> safe straight
 >> safe arc
 >> wheel_v_, wheel_w_ in ROTATE and MOVE: %.2f, %.2f
 >> [LAGER_ROTATION] target_direction_ is %.2f
 >> search_signals = %d
 >> FL & FR
\n >> SAFE ON, CENTER SIGNAL MISSING, CNT : %d
 >> target_dir = %.2f
 >> No FR & No FL
 >> FR & FL
 >> FL
 >> FR
 >> wheel_v: %.2f, wheel_w: %.2f
 >> case : REDOCKING_AFTER_DETACHING_STATION
 >> [check_ir_wf_finish_condition]
 >> SIGNAL_NONE, obs_sts: %d
 >> check ir: left wall finish
 >> check ir: right wall finish
 >> [check_wf_finish_condition] wf_safe: %d
 >> dist_sum = %.2f
 >> new_senID = IR in wf finish check
 >> get_safe() is true
 >> exceptional case: long WF
 >> abs_ang_sum = %.2f
[detectExceptionalMotion] ^^^^ REPEATED MOTION DETECTED ^^^^ motion_cnt: %d, diff_dist: %.2f\n
[detectExceptionalMotion] ^^^^ TARGET DIRECTION BLOCKED DETECTED ^^^^ motion displacement: %.2f\n
st_docking_exception
[st_docking_exception] trial_cnt: %d, target_dir: %.2f\n
Fail to get docking signal\n
st_docking_normal
st_docking_exception_avoid
st_docking_exception_init
 >> [save_wf_direction] dir: %1.0f (x:%.1f,y:%.1f) flag: %d
 >> [motion_to_avoid_obstacle] wf_start_flag = %d, wf_finish_flag = %d
 >> in motion_to_avoid fn, obstacle_type = %d
 >> OBS_STOP or others, target_dir: %.2f
 >> SLIP_SKIP_CNT : %d\n
 >> SLIP_SKIP_INITIALIZE [TIME_OUT] : %ld\n
 >> OBS_CLOSE. Reduce speed. True speed v:%.2f, w:%.2f
[Docking] No hander to avoid obstacle (type: %d)\n
 >> [motion_to_seek_station]
 >> seeking_cnt: %d, diff_pose:[%.2f, %.2f], cur_pose_q: %.2f, ang_diff: %.2f, ang_sum: %.2f, rand_w = %.5f
 >> Detect island obstacle in Skip WF Motion
 >> <WF_MOTION> >> Detect failure in escape motion. Now restart escape motion w/ WF motion.
 >> go straight, m_skip_wf_arc_cnt = %d
 >> straight motion in WF_MOTION (%d)
 >> motion_to_avoid_obstacle called in WF_MOTION
 >> Save WF initial position.
 >> (m_wf_init_pose.x: %.2f, m_wf_init_pose.y: %.2f)
 >> chk island, wf_init_p:[%.2f, %.2f], min_p:[%.2f, %.2f], max_p:[%.2f, %.2f]
 >> seeking_cnt: %d, diff_p:[%.2f, %.2f], cur_q: %.2f, ang_diff: %.2f, ang_sum: %.2f
 >> m_pre_wf_direction = LEFT_WALL
 >> m_pre_wf_direction = RIGHT_WALL
 >> m_pre_wf_direction = ???
 >> seeking_cnt: %d, ang_sum: %.2f, wf_init_p:[%.2f, %.2f], diff_p:[%.2f, %.2f] >>
 >> <SKIP_WF_MOTION> Detect island obstacle in WF_MOTION.
 >> <SKIP_WF_MOTION> Escape Motion is completed. Return to Skip WF Motion.
[st_docking_exception] dq: %.2f, sum_ang: %.2f
 >> turning degrees: %.2f
 >> trial_cnt: %d, timeout_cnt: %d, timeout_lmt: %d\n
[st_docking_normal] ignore the repeated motion since the status is %d\n
[st_docking_normal/react] REPEATED MOTION!!!!! Handling the exceptional situation\n
[st_docking_normal] ignore the no motion toward target since the status is %d\n
[st_docking_normal/react] NO MOTION TOWARD TARGET!!!!! Handling the exceptional situation\n
\n[st_docking] Exceptional situation, RegStn: %d, Stn_flg:%d, Stn_cnt: %d
\n[st_docking] Exceptional situation
\n[st_docking] Normal situation, RegStn: %d, Stn_flg:%d, Stn_cnt: %d
\n[st_docking] Normal situation
 >> Docking station contacted\n
>> Right_bump_on
 >> Left_bump_on
 >> Both_front_bump_on, Extra turning
 >> Both_front_bump_on
 >> Not bumping condition
 >> station_contact_flg is true
DOCKING
[st_docking] Return to Docking Mode
, new_sen_ID = %s, cur_sen_ID = %s
IDLE
WALLFOLLOWING
[st_docking] <SKIP_WF_MOTION>\n
[Docking] Seeking -> Docking\n
[st_docking-DOCKING_MODE] Ignore IR when Center & Safe\n
[st_docking-DOCKING_MODE] to IR_WF_FINISH_MOTION\n
[st_docking-DOCKING_MODE] DOCKING by not normal wf: left\n
[st_docking-DOCKING_MODE] DOCKING by not normal wf: right\n
[st_docking-DOCKING_MODE] DOCKING by not normal wf: front\n
[st_docking-WALLFOLLOWING_MODE] Changed to DOCKING by safe sig\n
[st_docking-WALLFOLLOWING_MODE] WF to DOCKING by not normal wf: left\n
[st_docking-WALLFOLLOWING_MODE] WF to DOCKING by not normal wf: right\n
[st_docking-WALLFOLLOWING_MODE] WF to DOCKING by not normal wf: front\n
 >> motion mode: %s(%s), obs = %s, go_straight: %d
 >> motion mode: %s, obs = %s, go_straight: %d\n
[st_docking] target_dir: %.2f, wf_start_flg: %d
[st_docking] pre mode: %s, motion mode: %s, before mode: %s\n
(%8ld)[FSM.DOKCING] Docking mode exit after %ld ms(skip wf: %ds, signal docking: %ds)\n
st_docking
(%8ld)[FSM.DOCKING] Docking mode init\n
           redocking=%d\n
SKIP_WF_MOTION
WF_MOTION
NO_SIGNAL
HANDLE_CENTER
HANDLE_CENTER_SAFE
HANDLE_SAFE
HANDLE_LEFT
HANDLE_RIGHT
HANDLE_WIDE
ROTATE_AND_MOVE
IN_MOTION
CENTER_FROM_SIDE
HANDLE_OPPOSITE_STATION
IR_WF_FINISH_MOTION
HANDLE_PRE_CENTER_SAFE_BUMP
HANDLE_CENTER_SAFE_BUMP
REDOCKING_AFTER_DETACHING_STATION
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
st_exit
 * exit action processing...
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
st_idle
(%8ld)[FSM.IDLE] Pause SLAM by wheel lift.\n
st_id_wait
(%8ld)[FSM.IDLE] ctl-motor-off timeout %ld ms. (too long >= %d)\n
st_id_init
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
st_init
st_i_postproc
st_i_preproc
st_i_resetmap
 * Resetting global map...\n
st_i_resetgyro
st_i_resetcoord
st_i_resetloc
(%8ld)[FSM.INIT] ctl-motor-on timeout %ld ms. (too long >= %d)\n
 * Resetting sector map...\n
 * Clearing sector map...\n
(%8ld)[FSM.INIT] Pose reset success!\n
(%8ld)[FSM.INIT] Pose reset failure!\n
(%8ld)[FSM.INIT] Gyro reset success!\n
(%8ld)[FSM.INIT] Gyro reset failure!\n
(%8ld)[FSM.INIT] Localization stopped!\n
(%8ld)[FSM.INIT] Localization stop failed!\n
(%8ld)[FSM.INIT] Localization disabled!\n
(%8ld)[FSM.INIT] Localization started!\n
(%8ld)[FSM.INIT] Localization start failed!\n
 * Resetting status log...
Status log reset error! (Still writing odometry)\n
8V=M
>R' >3
T>fff>
'?#J+?
5?\v$8?\b=;?
I?\rqL?
Q?X9T?\v
Y?vq[?-
\\m?i
p?J\fr?J{s?
v?9Ew?
ex?Gry?
dz?#J{?
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
st_drag_emergent
st_drag_avoid
st_drag_track
st_drag
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
st_m_exception
st_m_right
st_m_left
st_m_backward
st_m_forward
st_m_stop
st_m_init
queued_enable_camera
st_manual
queued_disable_camera
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
st_slave
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
RCChange Vertex :
Update Vertex :
Revert Vertex :
Extend Vertex :
 (%.1f, %.1f) (%1.f, %1.f)\r\n
CCW\n
Right WallFollowing\n
Left WallFollowing\n
Meet Out line :
X_MAX\n
Y_MAX\n
X_MIN\n
Y_MIN\n
Spot is completed by inside line!!\n
Spot is completed by distance!!\n
st_s_sp_round_turn
st_spot
st_s_emergency
st_s_init
st_s_av_rotate
st_s_av_follow_line
st_s_end
st_s_sp_rotate_to
st_s_sprial
st_s_sp_move_to
st_s_av_follow_wall
st_s_ed_follow_wall
st_s_em_follow_wall
st_s_av_init
st_s_sp_init
st_s_avoid
st_s_ed_stop
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
 * [RELOCATION] Init: Erase Global Map (%+3d,%+3d)\n
 * [RELOCATION] Init: Erase Sector Map (%+3d,%+3d)\n
 * [RELOCATION] Init: Reset Local Map\n
 * [RELOCATION] Init: Reset Sensor Array\n
 * [RELOCATION] Init: Reset Slip\n
 * [RELOCATION] Init: Modiby Global Map (%+3d,%+3d)\n
 * [RELOCATION] Init: Modify Sector Map (%+3d,%+3d)\n
st_relocation
st_r_end
 * [RELOCATION] End: INVALID!\n
 * [RELOCATION] End: SUCCESS!\n
 * [RELOCATION] End: FAIL!\n
st_r_relocate
 * [RELOCATION] Relocate(Count=%d)\n
st_r_turn
 * [RELOCATION] Turn(Count=%d)\n
st_r_finalize
st_r_t_stop
st_r_t_rotate
st_r_t_motoron
st_r_f_motoron
st_r_f_localize
 * [RELOCATION] Localize(%d ms)\n
st_r_f_stopandwait
 * [RELOCATION] StopAndWait(%d ms)\n
st_r_f_align
 * [RELOCATION] Align\n
st_r_f_moveto
 * [RELOCATION] MoveTo\n
st_r_f_turnto
 * [RELOCATION] TurnTo\n
                      Record Size  : %d\n
                      Record Range : (%d, %d) (%d, %d)\n
 * [RELOCATION] Init: Revert Global Map\n
 * [RELOCATION] Init: Revert Sector Map\n
st_r_init
 * [RELOCATION] Init: Total LM = %d\n
 * [RELOCATION] Init: Wait %d ms\n
 * [RELOCATION] New Command -> DEFERRAL\n
 * [RELOCATION] New Command -> EXIT\n
(%8ld)[FSM.RELOCATION.TURN] ctl-motor-on timeout %ld ms. (too long >= %d)\n
(%8ld)[FSM.RELOCATION.TURN.ROTATE] Timeout in rotate! (%ld ms >= %d ms)\n
(%8ld)[FSM.RELOCATION.TURN.ROTATE] Stopped by %s!\n
(%8ld)[FSM.RELOCATION.FINALIZE.TURNTO] Timeout in turn-to! (%ld ms >= %d ms)\n
(%8ld)[FSM.RELOCATION.FINALIZE.TURNTO] Stopped by %s!\n
(%8ld)[FSM.RELOCATION.FINALIZE.MOVETO] Timeout in move-to! (%ld ms >= %d ms)\n
(%8ld)[FSM.RELOCATION.FINALIZE.MOVETO] Stopped by %s!\n
(%8ld)[FSM.RELOCATION.FINALIZE] ctl-motor-on timeout %ld ms. (too long >= %d)\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
st_transmit_image
%s do_escape=%d reset_sector=%d station_start=%d
LARGE SECTOR
SMALL SECTOR
AREA_CLEANING
CREATE_MAP
EXPO
KSB6934 W/F
KSB6934 W/O W/F
     >>> No table to DEL
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
 \n\n\n\t\t putEscapeTrajectory[%d]( x: %.2fmm, y: %.2fmm), (deg: %.2f) \n\n\n
 angle count: %d, delta: %.2f\n
 Confined Exit(%3.1f>1000) or (%3.1f>450 and angleFree:%d):\n
 Confined Fault(%3.1f>720) or (%3.1f>6000)\n
 confined area escape succeed\n
 confined area fault \n
INIT MAP SIZE:[%d %d] [%d %d]\n
### successViaOrFailStop #0 - 0(Robot_Passed_Path Mask1)\n
### successViaOrFailStop #0 - 1(Robot_Passed_Path Mask2(Except BumpClose & Station Halo)\n
### successViaOrFailStop #1 - 0(Overriding ROBOT_PASSED or CELL_BIT_KNOWN)\n
### successViaOrFailStop #1 - 1(Overriding ROBOT_PASSED or ROBOT_CAN_PASSED or CELL_BIT_KNOWN)\n
### successViaOrFailStop #2(Don't Find Available Goal & Path)\n
### MOVE_TO_AREA, Adjust Bound[%d %d][%d %d]\n
### MOVE_TO_AREA, Start Via Moving, Arrive Temp Goal\n
### MOVE_TO_AREA, room position %.1f %.1f\n
### MOVE_TO_AREA, Area Moving Retry Accum:(%d/%d)\n
### MOVE_TO_AREA, Don't Find Available Path\n
 IR:WF_RIGHT \n
 IR:WF_LEFT \n
 >> Check Blocked Unclear Cell & Path >> \n
 >> Known Goal >> \n
 >> Robot Cell:(%d,%d),Robot Area Size:%d Open Space Size:%d>> \n
 >> Goal Cell:(%d,%d),Goal Area Size:%d Open Space Size:%d >> \n
 >> Goal Area is Small: Find Another Goal\n
 >> Find Available Goal:%d\n
 >> Don't Find Another Goal:%d\n
 >> Too many iteration\n
 >> found Blocked Unclear Cell : Start:(%d,%d) -> Goal:(%d,%d)\n
 >> found Blocked Unclear Cell Countmap\n
 >> found Blocked Unclear Cell Path\n
 >> found Blocked Unclear Cell Optimal Path\n
 target goal (%d, %d)\n
 No Path But Goal\n
 >> found Blocked Unclear Cell But Outside map\n
 >> No Blocked Unclear Cell \n
 >> Use ROBOT_CAN_PASSED \n
 >> Use ROBOT_PASSED \n
 finding ceiling angle failed\n
### First Via List:\n
(%d %d)\n
[B]MAP SIZE:[%d %d] [%d %d]\n
S(%d %d) G(%d %d) C(%d %d) D(%3.1f)\n
[A]MAP SIZE:[%d %d] [%d %d]\n
MINIJ(%d %d) MAXIJ(%d %d)\n
###11 room position map[%.1f %.1f] slam[%.1f %.1f]\n
### ROBOT_MOVE_VIA is OK, room position %.1f %.1f\n
### FIRST_MOVING_FOR_AREA_CLEANING, destination %.1f %.1f\n
### ROBOT_MOVE_VIA is not OK\n
### MOVE_TO_AREA, Arrive Temp Goal -> Move To Real Goal\n
### MOVE_TO_AREA,Reason(Resume,Completed,Timeout)\n
### MOVE_TO_AREA, Via Length[%d %d][%d %d]\n
### MOVE_TO_AREA, Cur Dist(%3.1f) Bef Dist(%3.1f)\n
### MOVE_TO_AREA, Temp Target Changed [%3.1f %3.1f]\n
### MOVE_TO_AREA, After WF, Target Restored\n
### MOVE_TO_AREA, After WF, Target Changed[%3.1f %3.1f](Try Num:%d)\n
### MOVE_TO_AREA, can not move to target(m_area_moving_retry: %d > 6 or m_area_moving_retry_accum: %d > %d\n
*** m_crossclean_cnt:%d , m_double_zigzag_flag:%d dzs:%d n getCrossCleanCnt \n
<<getCrossCleanCnt>> 0000000000000 > %d ===
[CLEAN_COMPLETED] TmeClnAcc %d InfCln %d ClnCnt %d nDZZcnt %d\n
[CLEAN_COMPLETED] Try Follow wall sector boundary\n
[CLEAN_COMPLETED] ReStart Time Elapse\n
** ReStart Time Elapse!\n
[AUTO PLAN - RM_ADV_INFO:AUTO] id: %d, time: %d, corner_count: %d, cell_size: %d, short_dist_flag: %d\n
#CREATE_MAP### station_start %d, fst_cln %d, mode %d save_map %d %d no_save_trj_flag %d\n
/opt/data/robot-network/files/M%03d.map
/opt/data/robot-network/files/M%03d.smap
### SaveMap %s\n
### re-SaveMap %s\n
/opt/data/robot-network/files/M999.map
/opt/data/robot-network/files/M000.map
/opt/data/robot-network/files/M000.smap
/opt/data/robot-network/files/map.zip
/opt/data/robot-network/files
/usr/bin/zip map.zip M*.map &
total %d us pro1 %d us proc2 %d us\n
### area que is empty\n
### Don't save trajectory room %d, sts %d\n
### SaveTrajectory room %d -> %s\n
*** DOUBLE_ZIGZAG_STEP1 \n
*** DOUBLE_ZIGZAG_STEP2 \n
*** DOUBLE_ZIGZAG_STEP3 \n
\n pass 1\n
*** m_crossclean_cnt:%d , m_double_zigzag_flag:%d dzs:%d in setCrossCleanCnt \n
\n\n\n\n\n\t\t\t ::::: ALL_SECTOR_CLEAN_COMPLETED ::::: %d \n\n\n\n\n
double zigzag check1 : %d\n
double zigzag check2 : %d\n
/opt/data/robot-network/files/sp%02d.trj
[MOVE_TO_SECTOR_BOUNDARY] RIGHT WF left=%d, right=%d\n
[MOVE_TO_SECTOR_BOUNDARY] LEFT WF left=%d, right=%d\n
[MOVE_TO_SECTOR_BOUNDARY] CHANGE WF DIRECTION RIGHT -> LEFT\n
[MOVE_TO_SECTOR_BOUNDARY] CHANGE WF DIRECTION LEFT -> RIGHT\n
[WF AROUND SECTOR] over angle \n
[WF AROUND SECTOR] over distance \n
 >>>>> C00 case<STUCK>, but Err Off Condition ----> GET_NEXT_SECTOR \n
 >>>>> C00 case<STUCK>\n
*** DOUBLE_ZIGZAG_STEP1 : %5.5f \n
*** DOUBLE_ZIGZAG_STEP2 : %5.5f \n
*** DOUBLE_ZIGZAG_STEP3 : %5.5f \n
*** After SectorOrigin : %5.5f \n
\n\n\n\n\n\t\t\t ::::: ALL_SECTOR_CLEAN_COMPLETED ::::: %5.5f \n\n\n\n\n
::::: After SectorOrigin : %5.5f \n
 max(%3.1f %3.1f) min(%3.1f %3.1f) CONFINED dist(%3.1fmm < 400mm?)\n
 num of samples %d  Confined Area Identified\n
  command : %d, pos(%.2f, %.2f)\n
 \t\t >>> isLimitCitycleBetween() <<< \n
 \t\t >>> [%d] command:%d, pos[%d]-(%.2f, %.2f) <<< \n
 \t\t >>> isSameActionOnSamePosition()\n
[moveToAreaRecleaningPosition] NORMAL_PATH_FOLLOW WF_RIGHT (%d) \n
[moveToAreaRecleaningPosition] GOAL IS DEAD, FINISH:MOVE_TO_POSTION) \n
[moveToAreaRecleaningPosition] AVAILABLE??: GOAL IS DEAD, FINISH:MOVE_TO_POSTION) \n
 >> [WALL_FOLLOWING_OBSTACLE<(%0.1f %0.1f), (%d %d)>]\n
 <> WALL_FOLLOWING DeltaAngle OVER, FINISH:MOVE_TO_POSTION)) \n
 <> WALL_FOLLOWING DIST OVER 10cell, FINISH:MOVE_TO_POSTION)) \n
 <> GOAL IS DEAD, FINISH:MOVE_TO_POSTION)) \n
\n[isAreaCleaningReallyCompleted] lower(%d,%d), upper(%d,%d)\n
[isAreaCleaningReallyCompleted] find_goal(%d,%d)\n
[isAreaCleaningReallyCompleted] find path to (%d,%d)\n
[isAreaCleaningReallyCompleted] Completed\n
 >> Check Unclear Cell & Path Outside Station Halo >> \n
 >> No Virtual Sensor Near \n
 >> found Unclear Cell & Path Outside Station Halo Cell : (%d,%d)->(%d,%d)\n
 Make Path\n
 1st via (%d, %d)\n
 >> Via Count(Head, Optimal): (%d, %d)\n
 >> found Unclear Cell Outside Halo But Outside map\n
 >> No Unclear Cell Outside Halo \n
 >> Check Escape Cell >> \n
 >> found Escape Cell : (%d,%d)->(%d,%d)\n
 >> found Escape Cell But Outside map\n
 >> No Goal Cell for Escape \n
\n\n\n >>>>> >>>>> (RE)START CLEANING SECTOR AT [%d, %d] >>>>> >>>>> \n\n\n
[START_SECTOR_CLEAN] sector index ( %d, %d)\n
start-resume for AREA_CLEAN_MODE
MAP_ID:%d\n
!sectorRegenerationWhileMoving!:m_CurrSectorPtr:NULL\n
 arrived pt:(%.2f,%.2f), current point:(%.2f,%.2f), target point (%.2f,%.2f), target idx:%d\n
 >> [ESCAPE_RETRY(%d)]\n
!escapeRetry!:m_CurrSectorPtr,NULL\n
[ESC](m_wf_dir(%d) [ang_diff %.1f ang_dest %.1f] [(via:(%d %d) ang_now %.1f]\n
[ESC] Make Path-> Escape WithMoveToPoint\n
[ESC] Don't Make Path-> Keep WF\n
[ESC] Strange Case\n
SENSOR REASON
:IR\n
:BUMP\n
:EMC_TURN\n
:NARROW_PASS\n
:EMC_STOP\n
:UPPER_STUCK\n
:SOFT_BUMP\n
:MAGNET\n
:BOTT\n
:SG_FENCE\n
:SG_GATE\n
:LIFT\n
:CLIMB\n
:ST_FENCE\n
:WSTUCK\n
:MB_TANGLE\n
:SB_TANGLE\n
:SLIP\n
:BACK_CLIMB\n
 >> [REAL SENSOR -> WALL FOLLOWING]\n
 >> Don't IgnoreStationFenceFlag >> [findCloseBlockedUncleanCell]\n
 >> IgnoreStationFenceFlag >> [isCapturedInsideStationHalo]\n
 <> [ESC] cleaned sector and else sensor event (%d, %d) \n
 Available pSector\n
 No pSector\n
Similar Escape Pos Case: Cur(%3.1f %3.1f) Bef(%3.1f %3.1f) Dist(%3.1f)\n
Different Escape Pos Case: Cur(%3.1f %3.1f) Bef(%3.1f %3.1f) Dist(%3.1f)\n
 >> [Dist Goal:%d Dist Via:%d)>]\n
 <> [Via Try Clear] \n
 >> [Init Wall Following]\n
 >> [VIA Try:%d]\n
 Start ESCAPE through WALL to (%d,%d) by VIA MOVE\n
 Start ESCAPE through WALL to (%d,%d) by TURN AND GO\n
 Start ESCAPE across HALO to (%d,%d) by VIA MOVE\n
 Start ESCAPE through HALO to (%d,%d) by turn and go\n
 Start ESCAPE_DECISION because of small sector(WholeMovingDistX:%3.1f WholeMovingDistY:%3.1f)\n
 Try ESCAPE Path Planning(%d)\n
 ESCAPE Path Planning: findCloseBlockedUnCleanCellWrapper()\n
 ESCAPE Path Planning: isCapturedInsideStationHaloWrapper()\n
 ESCAPE Path Planning: isCapturedSmallAreaWrapper()\n
 Don't Try ESCAPE Path Planning(%d)\n
 <> [ESC] FindGoalignorePathForEscape(no path) (%d, %d) \n
 >> [FIND UNCLEAR PATH]\n
 Through station HALO
 <> [ESC] uncleaned sector selected by path_planning (%d, %d) \n
 <> GOAL IS ALIVE <GOAL(%d %d)>]\n
 <> WF End Condition\n
 Angle(%3.1f < %3.1f)\n
 Dist(%3.1f < %3.1f), (%3.1f < %3.1f)\n
 minDist(%3.1f) m_wf_repeat_cnt(%d) m_try_robot_can_passed(%d)\n
 OverTurn(%d)\n
 <> [ESC] checkAbnormalWallFollowingWhileEscape(true) wall following (%d, %d) \n
 <> [ESC] Inside Halo\n
 \n\n\n\t >>>>>>>>>>  Into ESCAPE_CONFINED_NARROW_AREA by angle-----> \n\n\n
 <> Try Via:%d\n
<> ESCAPE_DECISION -> OVERTURN, BUT NO GOAL\n
 OverDistance(%d)\n
 <> [ESC] escapeDistanceOver(true) wall following (%d, %d) \n
\n\n\n\t >>>>>>>>>> Into ESCAPE_CONFINED_NARROW_AREA by length-----> \n\n\n
<> ESCAPE_DECISION -> OVER DISTANCE, BUT NO GOAL\n\n
<> ESCAPE_DECISION -> Path Condition\n
<> KEEP ESCAPE WALLFOLLOWING(1)\n
<> KEEP ESCAPE WALLFOLLOWING(2)\n
 >> [REAL SENSOR -> BUT VIA AGAIN: SG CASE(%d)]\n
 >> [WF_SAFE_END_CHECK]\n
 ESCAPE_WF_SAFE_END_CHECK, NOT SAFE\n
 >> Don't Make Countmap(%d,%d)>> \n
[ESCAPE CONFINED] Fault(%d/3)\n
 [ESCAPE CONFINED] Final Fault\n
 [ESCAPE CONFINED] Fault But Keep \n
 [ESCAPE CONFINED] initialize parameter \n
 [ESCAPE CONFINED] Retry(%d)\n
 [ESCAPE CONFINED] Keep \n
 <> arrived at NEW unCLEAN sector inside while moving to sector (%d, %d) \n
 <> arrived at the DESIRED sector inside while moving to sector (%d, %d) \n
!sectorInsideWallFollowingObstacle!:m_CurrSectorPtr:NULL\n
 <> sector boundary arrived while moving inside_sector \n
sectorInsideWallFollowingObstacle,m_CurrSectorPtr:NULL\n
  <> escape obstacle while moving inside_sector \n
    ir number : %d, dist : %u\n
   smallest ir number : %d, dist : %u\n
   ir turn to right
    ir turn to left
!vertexFinished!,m_CurrSectorPtr:NULL\n
moveToNextVertexOrFinish,m_CurrSectorPtr:NULL\n
moveToNextVertexOrFinish safe %d isDistanceOverTmp %d \n
 <> vertex completed at %d\n
 <> vertex completed abnormal wall following (%d, %d)\n
 <> boundary completed approximately inside (%d, %d)\n
 <> reverse direction move (%d, %d)\n
  <> vertex completed abnormal wall following outside (%d, %d)\n
 <> boundary completed approximately outside (%d, %d)\n
  <> vertex completed in outside (%d, %d)\n
 vertex arrived %d, (%.2f, %.2f)
  <> vertex completed at start point (%d, %d)\n
 >>>>> WALL_FOLLOWING inside (safe: %d) [%.2f, %.2f] >>>>> \n
 >>>>> WALL_FOLLOWING outside (safe: %d) [%.2f, %.2f] >>>>> \n
  abnormal heading angle in indentifying (%d, %d)\n
 >> [IDENTIFY_SECTOR_BOUNDARY ESC : VG]\n
 arrived first big sector bounday\n
SECTOR_INSIDE_WALL_FOLLOWING_OBSTACLE:m_CurrSectorPtr,NULL\n
 arrived first big sector boundary and keep wall-following\n
 rotate avoid\n
 rotate complete move to target index %d\n
 new vertex %d, rotate to (%.2f, %.2f)
 >> [FIRST_IDENTIFY_SECTOR ESC : VG]\n
  %d:(%d,%d)\n
  robot --> (%d, %d) \n
 <> normal path follow completed inside sector move\n
find_goal_cell_on_map_for_global_check(Goal Cell:%d %d)\n
Get Sector Fail\n
 <> [ESC] uncleaned sector selected by path_planning (%d, %d)\n
 >> [ESCAPE_DECISION]\n
 >> [ESC] GATE_FLAG : ignore(%d), detect(%d) \n
 >> m_NumOfEscapeTrials Over (%d) \n
Find Normal Path\n
Find CloseBlockedUnCleanCell Path\n
Find CaptureInsideStationHalo Path\n
Find GoalIgnorePathForEscape Path\n
Find GoalArbitraryPos Path\n
 >> [ESCAPE_CONFINED_NARROW_AREA] event_reason:(%d)\n
 \n\n\n\t -----> ESCAPE_CONFINED_NARROW_AREA(%d/3) <<<<<<<<< \n\n\n
 ESCAPE_CONFINED, STRANGE CASE:%d)\n
 >> [ESCAPE_WITH_WALL_FOLLOWING< GOAL(%d %d), (ESC_XY,ESC_DISTSUM)(%0.1f %0.1f)>]\n
 >> [ESCAPE_WITH_WALL_FOLLOWING<Event Reason:%d>]\n
 >> [ESCAPE_WITH_WALL_FOLLOWING[%d][%d][%d](%3.1f %3.1f)]\n
 <> Find UnClearCellAndPath\n
 <> GOAL IS DEAD, FIND GOAL AGAIN\n
 <(%0.1f %0.1f), (%d %d)>]\n
 <> KEEP WF / Small Moving(%3.1f %3.1f)\n
 ESCAPE_WALLFOLLOWING, STRANGE CASE:(%d)\n
 >> [ESCAPE_WITH_MOVE_TO_POINT:(%d %d)]\n
 >> [ARRIVE NEW SECTOR: ESCAPE SUCCESS]\n
 >> [SENSOR REASON]\n
>> [same robot position]
 >> [FALSE SENSOR]\n
 >> [FIND NORMAL PATH]\n
 >> [FIND ESCAPE PATH]\n
 >> [DON'T FIND UNCLEAR PATH]\n
 >> [ESCAPE SG]\n
 >> [CURRENT SUBSTATE:%d]\n
 >> [DEFAULT\n
 >> [NEXT SUBSTATE:%d COMMAND:%d]\n
 >> [ESCAPE MAIN:GET_NEXT_SECTOR]\n
 >> [ESCAPE MAIN:ESCAPE_FAILED]\n
 >> [ESCAPE MAIN:ARRIVE_NEW_SECTOR]\n
 >> [ESCAPE MAIN:MOVE_TO_NEXT_SECTOR]\n
\n\n\n ### ESCAPE_SECTOR: ARRIVE_NEW_SECTOR and then CLEAN_SECTOR \n\n\n
 >> [ESCAPE MAIN:MAKE_SECTOR]\n
ARRIVE_NEW_SECTOR: m_CurrSectorPtr-> NULL\n
 >> [ESCAPE MAIN:NORMAL_PATH_FOLLOW]\n
\n\n\n ### NORMAL_PATH_FOLLOW -> CLEAN_SECTOR \n\n\n
 >> [ESCAPE MAIN:FAULT_CASE]\n
 <> uncleaned sector selected by path_planning (%d, %d) \n
 <> uncleaned sector selected NO_PATH \n
 <> side sector selected (%d, %d)\n
 <> side sector selected NO_PATH \n
\n\n Return value from getSector() is NULL\n\n\n
 <> normal sector selected (%d, %d)\n
 <> normal sector selected NO_PATH \n
 >> find Unclear Cell & Path >>
findNextSector,m_CurrSectorPtr:NULL\n
 >> [ESCAPE_WITH_MOVE_TO_POINT]\n
 >> [ESCAPE_WITH_WALL_FOLLOWING]\n
 >> [FIND PATH: WALLFOLLOWING-> ROBOT_MOVE_VIA]\n
 >> [DON'T FIND PATH: >1.5turn]\n
 >> [FIND PATH BY HALO]\n
 >> [ESCAPE BY BUMPER, ANGLE]\n
 >> [ESCAPE BY BUMPER, DISTANCE]\n
 \n\n\n\t >>>>>>>>>> Into ESCAPE_CONFINED_NARROW_AREA by length-----> \n\n\n
 >> [Check Obstacle free]\n
 <> [ESC] isObsFree AccumulAngleOver(true) wall following (%d, %d) \n
 >> [M_SAFE FALSE: Path -> Wallfollowing again]\n
 >> [ESCAPE_CONFINED_NARROW_AREA]\n
 \n\n\n\t -----> ESCAPE_CONFINED_NARROW_AREA <<<<<<<<< \n\n\n
 >> [ESCAPE_RETRY]\n
 >>>>> edge_check ( N:%d, E:%d, S:%d, W:%d) >>>>> \n
 \n\n\t\t >>>>>>>>>>>>>>> Area Mode catch limit cycle <<<<<<<<<<<<<<< \n
 \n\n\t\t >>>>>>>>>>>>>>> catch limit cycle <<<<<<<<<<<<<<< \n
 \n\n\t\t CLEAN_SECTOR -> GET_NEXT_SECTOR \n
 \n\n\t\t CLEAN_SECTOR -> MOVE_FOR_RECLEANING \n
 \n\n\t\t GET_NEXT_SECTOR \n
 \n\n\t\t Same State \n
successViaOrFailStop,m_CurrSectorPtr:NULL\n
 <>  WALL_FOLLOWING_OBSTACLE WF_RIGHT (%d) \n
 <>  WALL_FOLLOWING_OBSTACLE WF_LEFT (%d) \n
 >> [WALL_FOLLOWING_OBSTACLE<(%f %f), (%d %d)>]\n
 <> moving failed abnormal wall following while moving outside_sector \n
 <> moving failed too long distance following while moving outside_sector \n
 <> path planning after first WF while moving outside_sector \n
 <> path planning after 2nd WF while moving outside_sector \n
 <> path planning ObsFree & NO_Climb while moving outside_sector :
 <> via(%.2f, %.2f), curr(%.2f, %.2f) \n
 <> GOAL IS DEAD, FIND GOAL AGAIN: WALLFOLLOWING) \n
 <> normal path follow completed \n
 <> re-path planning inside cleaned sector () \n
 <> new obstacle while moving \n
 <> prev_detected obstacle \n
 <> NORMAL_PATH_FOLLOW WF_RIGHT (%d) \n
 <> NORMAL_PATH_FOLLOW WF_LEFT (%d) \n
 <> GOAL IS DEAD, ARRIVE NEW SECTOR:NORMAL PATH FOLLOW) \n
\n\n\n ### ARRIVE_NEW_SECTOR and then CLEAN_SECTOR \n\n\n
 <> obstacle climbing while moving \n
 <> GOAL IS DEAD, FIND GOAL AGAIN:MOVE_TO_POSTION) \n
 <> AVAILABE??: GOAL IS DEAD, FINISH:MOVE_TO_POSTION) \n
 <> GOAL IS DEAD, FIND GOAL AGAIN: MOVE_TO_AVOID_OBSTACLE) \n
\t[MAKE_SECTOR] pole_max( %d, %d)\n
\n\t[MAKE_SECTOR] pole_min( %d, %d)\n
 map copy time check : start ---
 end  --- \n
 >> REMAKE FORWARD COUNT: EMPTY_LOAD_UNKNOWN: %d ->
%d
 >> REMAKE FORWARD COUNT: EMPTY_LOAD_WALL_REAL: %d ->
 >> REMAKE FORWARD COUNT: EMPTY_LOAD_WALL_DANGEROUS: %d ->
 >> REMAKE FORWARD COUNT: EMPTY_LOAD_WALL_SECTOR: %d ->
 >> REMAKE FORWARD COUNT: EMPTY_LOAD_CLEANED: %d ->
 >> REMAKE FORWARD COUNT: EMPTY_LOAD_LITTLE_CLEANED: %d ->
 >> REMAKE FORWARD COUNT: NO CASE: %d ->
 >> REMAKE FORWARD COUNT: EMPTY_LOAD_CLENED: %d ->
>> SMOOTH TURN REDUCE COUNT  %d ->
>> SECTOR_CLEAN_FIRST_START :
>> SECTOR_CLEAN_VIA_END_DECISION_NS :
>> SECTOR_CLEAN_MAIN_DECISION_NS_GO :
>> SECTOR_CLEAN_MAIN_DECISION_NS_BACK :
>> SECTOR_CLEAN_UNCONDITIONAL_RUN :
>> SECTOR_CLEAN_MAIN_DECISION_EW :
>> SECTOR_CLEAN_DIRECT_START_SMOOTH_TURN :
>> SECTOR_CLEAN_DIRECT_OBSTACLE_START :
>> SECTOR_CLEAN_DIRECT_OBSTACLE_START_AFTER_VIA :
>> SECTOR_CLEAN_RE_WALL_FW :
>> SECTOR_CLEAN_APPROACH_WALL_FW :
>> SECTOR_CLEAN_VIA_MAKE_PATH :
>> SECTOR_CLEAN_VIA_GO_REMAKE_COUNT_MAP :
>> SECTOR_CLEAN_VIA_OBSTACLE_START :
>> SECTOR_CLEAN_VIA_OBSTACLE_PRE_END_CHECK :
>> SECTOR_CLEAN_VIA_OBSTACLE_END_CHECK :
>> SECTOR_CLEAN_MUST_WALL_FW :
>> SECTOR_CLEAN_MUST_WALL_FW BY SENSOR :
>> SECTOR_CLEAN_MAIN_DECISION_EW_BY_SENSOR :
>> SECTOR_CLEAN_END :
>> ERROR STATE:!!!!!!!!!!!!!!!(AutoPlanner)
 action: %d, count: %d, motion: %d
 START CELL:(%d,%d)>>
 \n PATH_SEARCH_UP >>>>
 START CELL:(%d,%d)->GOAL CELL >>(%d, %d)
 \n PATH_SEARCH_DN >>>>
 \n PATH_SEARCH_FULL >>>>
 \n PATH_SEARCH_UNDER_CELL >>>>
 \n PATH_SEARCH_UNDER_CELL WO BOUND>>>>
 GOAL BOUND:(%d,%d),PATH BOUND >>(%d, %d)
>> SUCESS FULL SEARCH UNDER_CELL!!! (%d / %d)
>> SUCCESS FULL SEARCH!!! (%d / %d)
>> FULL SEARCH:%d : UNDERCELL SEARCH:%d!!
>> USE UNDERCELL
>> SUCESS FULL SEARCH UNDER_CELL WO BOUND!!! (%d / %d)
>> SUCESS FULL SEARCH!!! (%d / %d)
>> FULL SEARCH:%d : UNDERCELL WOBOUND SEARCH:%d!!
>> USE UNDERCELL WO BOUND
>> USE FULL SEARCH
>> FAIL FULL SEARCH!!! (%d / %d)
\n >> MAKE PASS:FULL
>> SUCESS!!!
\n >> FAIL LOW SEARCH COUNT!!!
\n >> FAIL LARGE SEARCH COUNT!!!
>> SUCCESS1:%d %d %d
>> FAIL1:%d %d %d
>> SUCESS2
>> FAIL2
>> NO CASE FAIL
>> SUCESS CHECK_DIR_NORTH  %d!!!
>> SUCESS CHECK_DIR_SOUTH  %d!!!
>> FIND OBSTACLE DIRECTION
>> SMOOTH TURN: MOTION_WF_UP_RIGHT
>> SMOOTH TURN: MOTION_WF_UP_LEFT
>> SMOOTH TURN: MOTION_WF_DN_RIGHT
>> MOTION_GO_WEST:  MOTION_WF_UP_RIGHT
>> MOTION_GO_WEST:  MOTION_WF_UP_LEFT
>> MOTION_GO_EAST:  MOTION_WF_DN_LEFT
>> MOTION_GO_EAST:  MOTION_WF_DN_RIGHT
>> DIR_N:CLEAN_DIRECTION_UP:CHECK_DIR_EAST:MOTION_WF_DN_LEFT
>> DIR_N:CLEAN_DIRECTION_UP:CHECK_DIR_WEST:MOTION_WF_UP_RIGHT
>> DIR_S:CLEAN_DIRECTION_UP:CHECK_DIR_EAST:MOTION_WF_DN_RIGHT
>> DIR_S:CLEAN_DIRECTION_UP:CHECK_DIR_WEST:MOTION_WF_UP_LEFT\t
>> HAVE TO FOLLOW WALL :MOTION_WF_UP_RIGHT
>> HAVE TO FOLLOW WALL :MOTION_WF_UP_LEFT
>> HAVE TO FOLLOW WALL :MOTION_WF_DN_RIGHT
>> HAVE TO FOLLOW WALL :MOTION_WF_DN_LEFT
[CLEAN_AROUND_STATION] finish clean station by Resume\n
\n[MOVE_TO_UP_STATION] planing_reason is %d\n
[MOVE_TO_UP_STATION] try approach to up side station by wf \n
[MOVE_TO_UP_STATION] ignore sensor event %d, try = %d \n
[MOVE_TO_UP_STATION] can not arrive up station by sensor event %d \n
[MOVE_TO_UP_STATION] arrive up station \n
[MOVE_TO_UP_STATION] ignore false sensor, try = %d \n
[MOVE_TO_UP_STATION]can not arrive up station \n
\n[CLEAN_UP_SIDE_STATION] planing_reason is %d\n
[CLEAN_UP_SIDE_STATION] stop wf and move to dn station\n
[CLEAN_UP_SIDE_STATION] finish clean up side station by by sensor %d \n
[CLEAN_UP_SIDE_STATION] ignore sensor event %d, try = %d \n
[CLEAN_UP_SIDE_STATION] can not arrive up station by sensor event %d \n
[CLEAN_UP_SIDE_STATION] ignore sensor, try = %d \n
[CLEAN_UP_SIDE_STATION] finish clean up side station\n
\n[MOVE_TO_UP_STATION_AGAIN] planing_reason is %d\n
[MOVE_TO_UP_STATION_AGAIN] try approach to dn side station by wf \n
[MOVE_TO_UP_STATION_AGAIN] ignore sensor event %d, try = %d \n
[MOVE_TO_UP_STATION_AGAIN] finish clean station by sensor %d \n
[MOVE_TO_UP_STATION_AGAIN] arrive dn station \n
[MOVE_TO_UP_STATION_AGAIN] ignore false sensor, try = %d \n
[MOVE_TO_UP_STATION_AGAIN] finish clean station \n
\n[MOVE_TO_DN_STATION] planing_reason is %d\n
[MOVE_TO_DN_STATION] try approach to dn side station by wf \n
[MOVE_TO_DN_STATION] ignore sensor event %d, try = %d \n
[MOVE_TO_DN_STATION] finish clean station by sensor %d \n
[MOVE_TO_DN_STATION] arrive dn station \n
[MOVE_TO_DN_STATION] ignore false sensor, try = %d \n
[MOVE_TO_DN_STATION] finish clean station \n
\n[CLEAN_DN_SIDE_STATION] planing_reason is %d\n
[CLEAN_DN_SIDE_STATION]finish clean station \n
[CLEAN_DN_SIDE_STATION]finish clean station by sensor event %d\n
[CLEAN_DN_SIDE_STATION] ignore sensor event %d, try = %d \n
[CLEAN_DN_SIDE_STATION] finish clean station \n
[CLEAN_DN_SIDE_STATION] ignore sensor, try = %d \n
[first_moving_for_area_cleaning] finished by Resume\n
[MOVE_TO_UP_DIR] END1 evt: %d sen: %d dist: %.1f esc_cnt: %d\n
[MOVE_TO_UP_DIR] END2 evt: %d sen: %d dist: %.1f esc_cnt: %d\n
[MOVE_TO_UP_DIR] END2_1 evt: %d sen: %d dist: %.1f esc_cnt: %d\n
[MOVE_TO_UP_DIR] END3 evt: %d sen: %d dist: %.1f esc_cnt: %d\n
[ROTATE_FOR_MOVING_DOWN] END1 evt: %d esc_cnt: %d\n
[ROTATE_FOR_MOVING_DOWN] END2 evt: %d esc_cnt: %d\n
[ROTATE_FOR_MOVING_DOWN] END2_1 evt: %d esc_cnt: %d\n
[ROTATE_FOR_MOVING_DOWN] END3 evt: %d esc_cnt: %d\n
[MOVE_TO_DOWN_DIR] END1 evt: %d sen: %d dist: %.1f esc_cnt: %d\n
[MOVE_TO_DOWN_DIR] END2 evt: %d sen: %d dist: %.1f esc_cnt: %d\n
[MOVE_TO_DOWN_DIR] END2_1 evt: %d sen: %d dist: %.1f esc_cnt: %d\n
[MOVE_TO_DOWN_DIR] END3 evt: %d sen: %d dist: %.1f esc_cnt: %d\n
###12 room position map[%.1f %.1f] slam[%.1f %.1f]\n
###13 ROBOT_MOVE_VIA is OK, room position %.1f %.1f\n
###14 ROBOT_MOVE_VIA is not OK\n
[KKS] detectConcave:%d\n
>> sensor:
>> SENSOR:%d %d %d(1:left,2:right)
### MOVE_TO_AREA, Sensor Reason: Cur Dist(%3.1f) Bef Dist(%3.1f)\n
### MOVE_TO_AREA, Start Via Moving, Sensor Reason\n
### MOVE_TO_AREA, Move again, room position %.1f %.1f\n
### MOVE_TO_AREA, Start WF, Sensor Reason\n
### WF_DIR(tmp_wf_dir) is %d(80:LEFT,90:RIGHT)\n
 ### MOVE_TO_AREA, Near Door Condition\n
 ### MOVE_TO_AREA, Near Door Retry(%d/7)\n
>> HAVETO MOTION_WF_RIGHT
>> HAVETO MOTION_WF_LEFT
>> HAVETO MOTION_WF_RIGHT:BUMP
>> HAVETO MOTION_WF_LEFT:BUMP
>> HAVETO MOTION_WF_RIGHT:BOTT
>> HAVETO MOTION_WF_LEFT:BOTT
>> HAVETO MOTION_WF_RIGHT:SLIP
>> HAVETO MOTION_WF_LEFT:SLIP
>> HAVETO MOTION_WF_LEFT:SLIP DEFAULT
>> HAVETO MOTION_WF_LEFT:NO REASON
>> DON'T MAKE WF CONDITION
>> front sensor:
:TRUE\n
:FALSE\n
 >> CLEAN_DIRECTION_DN_PATH_SEARCH_UNDER_CELL:%d,%d
>> SUCESS DIRECTION SEARCH!!! GOAL(%d, %d)
 >> FAIL: CLEAN_DIRECTION_DN_PATH_SEARCH_UNDER_CELL:%d,%d
\n >> MAKE DOWN PASS:ONLY DOWN
>> FAIL!!!
>> HAVETO MOTION_WF_UP_RIGHT
>> HAVETO MOTION_WF_DN_RIGHT
>> HAVETO MOTION_WF_UP_LEFT
>> HAVETO MOTION_WF_DN_LEFT
>> ONLY SENSOR: WF DIRECTION
\n\n [#STEP %3d )
*** DIRECTION CHANGE ***
[ DIRECTION UP >
[ DIRECTION DN >
 < NORTH_CLEANED ]
 < SOUTH_CLEANED ]
\n INPUT---------
[SECTOR_CLEAN_FIRST_START] fnc_type_detail %d,  m_SectorOrigin.q %+6.1f, dir[%d %d]\n
FIRST START  robot_dir = %d
add_forward_count_for_go is true! \n
add_forward_count_for_go is false! \n
>> UNCONDITIONAL RUN
>> MAKE_NS_COMMAND_FIRST_BACK
>> [ north %d, south %d ]
>> [close_space:NORTH ]
>> [close_space:SOUTH ]
>> [open_space:N:%d S:%d]
>> LINE CHECK
>> NORMAL WALLFOLLOWING_DOWN
>> DOWN VIA
>> NORMAL WALLFOLLOWING_UP
>> VIA MOVING
>> HAVETO WALLFOLLOWING
>>#### CHECK UP_DOWN DIRECTION
>> [ north %d %d, south %d %d]
>> SENSOR DETECTED: HAVETO WALLFOLLOWING
>> [ VIA AGAIN robot_dir north %d, south %d ]
>> MAKE_NS_COMMAND_SMOOTH
>> SECTOR_CLEAN_VIA_MAKE_PATH, PATH FAILED: HAVETO WALLFOLLOWING
>> ROBOT(%d, %d, %.1f), GOAL(%d, %d)
>> END VIA OBSTACLE: ARRIVE TO GOAL!
>> GOAL IS ALIVE
>> CAN ARRIVE TO GOAL
>> SUCESS MAKE NEW COUNT MAP
 Cur_Pose(%3.1f %3.1f %3.1f) Target_Pose(%3.1f %3.1f %3.1f)
 ATAN angle:(%3.1f) Current Angle:(%3.1f)
>> Current CELL:(%d %d), Target CELL:(%d %d)\n
>> ANGLE:%f, close_front:%d(angle:%3.1f), sensor_front:%d wall_count:%d wall_type:%d
>> RIGHT_WALL_FOLLOWING BY MAP
>> LEFT_WALL_FOLLOWING BY MAP
>> WALL_FOLLOWING SELECTED BY SENSOR, FIND MAP PATH
>> RIGHT_WALL_FOLLOWING BY MAP:INVERSE
>> LEF_WALL_FOLLOWING BY MAP:INVERSE
>> LEFT_WALL_FOLLOWING BY MAP:INVERSE
>> RIGHT WALL_FOLLOWING BY MAP:INVERSE
>> CANNOT ARRIVE TO GOAL
>> MAKE VIA AGAIN
>> VIA_OBSTACLE_START: GOAL IS DEAD!
 SECTOR_CLEAN_VIA_OBSTACLE_END_CHECK -- sector!!
>> END VIA OBSTACLE: DISTANCE OVER!
>> END VIA OBSTACLE: ANGLE OVER!
 Real(%3.1f %3.1f %3.1f), Cur_Pose(%3.1f %3.1f %3.1f)
>>Angle:%f\n
>> END VIA OBSTACLE: LEFT ANGLE OPEN!
>> END VIA OBSTACLE: RIGHT ANGLE OPEN(rotate_halo=%d)!
>> END VIA OBSTACLE: RIGHT ANGLE OPEN!
>> END VIA OBSTACLE: LEFT ANGLE OPEN(rotate_halo=%d)!
>> OBSTACLE_END_CHECK: PATH IS DEAD, MAKE VIA AGAIN!
>> OBSTACLE_END_CHECK: GOAL IS DEAD!
>> NOT SAFE
>> ROBOT(%d, %d), GOAL(%d, %d)
>> SUCESS MAKE NEW COUNT MAP:GENERAL
>> FAIL MAKE NEW COUNT MAP:GENERAL
>> ViA AGAIN
>> REMAKE_COUNT_MAP:GOAL IS DEAD
>> HAVETO WALLFOLLOWING_BY_SENSOR
\n##################################
\n   SECTOR CLEANED OK!! [%d, %d]
\n OUTPUT --------- action = %d,  count = %d, motion = %d
\n ### out order same!!!: pre_action_command.order:%d, action_command.order:%d
\n ##############################################################################
\n ### [[[[ motion %d >> motion %d >> motion %d >> motion %d >> motion %d]]]] ###
\n ##############################################################################\n
>> [same robot position:%d ]
>> [before same robot position:%d ]
COMPLETE:MOTION_GO_AGAIN:SECTOR_CLEAN_MUST_WALL_FW RO(:%d)\n
COMPLETE:MOTION_GO_AGAIN:UNCONDITIONAL RUN, RO(%d)\n
COMPLETE:MOTION_GO_AGAIN:DECISION_NS_BACK, RO(%d)\n
SLIP(ERROR) or BACK_CLIMB:SECTOR CLEAN MUST WALL FW\n
\nComplete\n
COMPLETE:MOTION_GO_VIA:SECTOR_CLEAN_VIA_END_DECISION_NS\n
COMPLETE:MOTION_GO_AGAIN:SECTOR_CLEAN_MAIN_DECISION_NS_GO RO(:%d)\n
\nWallFollowing Complete\n
\nMARK TO SGFENCE by FollowWallStop\n
TIMEOUT:Start Again\n
FALSE_SENSOR:WALLFOLLOWING\n
FALSE_SENSOR:MAKE VIA AGAIN\n
FALSE_SENSOR:SECTOR_CLEAN_UNCONDITIONAL_RUN\n
Else Case\n
(%8ld)[AUTOPLAN] Expo Cleaning Start.\n
(%8ld)[AUTOPLAN] Large Sector Cleaning Start.\n
********** m_double_zigzag_flag : %d , m_double_zigzag_flag_sub : %d\n
********** m_demo_startang_flag error\n
(%8ld)[AUTOPLAN] Small Sector Cleaning Start.\n
(%8ld) STATE: %d( %d) -----------------> \n
 Start ESCAPE through WALL to (%d,%d) by turn and go\n
 Start ESCAPE because of small sector\n
\n [%d] \n
double zigzag check3 : %d\n
[AP:FW] y=%3d (%+7.1f), command=%3d, safe=%d\n
double zigzag check4-1 : %d\n
double zigzag check4-2 : %d\n
double zigzag check5 : %d\n
(%8ld)--------------------> STATE: %d( %d), command(%d) \n
(%8ld)[AUTOPLAN] KSB6943 WF Cleaning Start.\n
(%8ld)[AUTOPLAN] KSB6943 WO WF Cleaning Start.\n
m %d n %d\n
magnetic_pose_array_base %.1f %.1f\n
org ij[%d %d], org ij[%d %d]\n
makeSector, m_CurrSectorPtr:NULL\n
[MakeSector - not use extracted angle because of mod_bott_action]\n
[MakeSector - BOTT_DIR_FRONT] angle %.1f %.1f %.1f\n
[MakeSector - BOTT_DIR_LEFT] angle %.1f %.1f %.1f\n
[MakeSector - BOTT_DIR_RIGHT] angle %.1f %.1f %.1f\n
[MakeSector - BOTT_DIR_NONE]\n
!makeSector!,m_CurrSectorPtr:NULL\n
[MakeSector] changed direction by Toggle\n
[MakeSector] angle %.1f mod_angle %.1f changed direction by Cliff\n
!makesector!,m_CurrSectorPtr:NULL\n
MINCELL(%d %d) MAXCELL(%d %d)\n
\n * SectorOriginq is %0.1f \n
 don't change SectorOrigin Q\n
#7 m_SectorOrigin %.1f %.1f %.1f\n
/opt/data/robot-network/files/Master.map
SLAM MAP Load Success:%s\n
SLAM MAP Load Fail:%s\n
 * Align Ceiling Angle to %0.1f\n\n
 SECTOR CLEAN_END\n
 m_CleaningCount = %d, m_CleaningMode = %d, m_CurrSectorPtr = %d \n
Move For Re-cleaning\n
resize door #1 %d\n
resize door #2 %d\n
Resize & Retry isAreaCleaningReallyCompleted\n
Resize & No Retry\n
CleanigCount(%d), GET_NEXT_SECTOR\n
 ### dist %.1f goal[%.1f %.1f] pos[%.1f %.1f] \n
[fence] fnc_type_detail %d,  m_SectorOrigin.q %+6.1f
 => %+6.1f\n
### erase Trajectory %s\n
Small Area(%3.1f %3.1f) (%3.1f %3.1f) but ignore %d\n
[AUTO] Cleaning Cnt %d, Time %d\n
Small Area(%3.1f %3.1f) (%3.1f %3.1f)\n
Large Area(%3.1f %3.1f) (%3.1f %3.1f)\n
(%8ld)--------------------> STATE@#1: %d( %d), command(%d) \n
(%8ld)--------------------> STATE@#2: %d( %d), command(%d) \n
****************> mx_auto_planning::control end\n
%s StartMode=%s
%s clean_completed=%d,%d cleaned:[cnt=%d time=%d cell=%d corner=%d short_dist=%d] make_robot_passed=%d reduce_obs_cnt=%d ignore:[sg_gate=%d st_fence=%d dust=%d] error=%d acm_result=%d
Reason=%s
Action=%s
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
C[GOTO] Goto mode FAIL, but Change of Result State <FAIL> => <SUCCESS>\n
[GOTO] Move To Destination! %d times\n
[GOTO] moveto planning fail : moveto_cnt:%d\n
[GOTO] via(%d points):
[GOTO] right W/F\n
[GOTO] left W/F\n
sensor reason %s\n
bump Front %d %d\n
bump Left %d %d\n
bump Right %d %d\n
bott Front\n
bott Left\n
bott Right\n
SLIP Left %d %d\n
SLIP Right %d %d\n
SLIP etc %d %d\n
UPPER_STUCK Front %d %d %d\n
UPPER_STUCK Left %d %d %d\n
UPPER_STUCK Right %d %d %d\n
ir [%02d] %03d\n
[GOTO] Change Goal(%3.1f %3.1f) -> (%3.1f %3.1f) - HOMING_STOP_CHNG_DEST\n
[GOTO] dock sig wide %d\n
[GOTO] goto_planning_complete m_exception_sg: true\n
[GOTO] goto_planning_complete dist in\n
[GOTO] Complete w/WideSig : %.1f (%.1f, %.1f, %.1f)\n
[GOTO] No HOMING_STOP_TRAN_DOCK %d \n
[GOTO] m_wf_esc_cnt > 0, modified finding dist %.1f -> %.1f\n
[GOTO] Undefined GOTO TYPE\n
[GOTO] temp_finding_dist %.1f m_wf_esc_cnt %d\n
[GOTO] Complete : %.1f (%.1f, %.1f, %.1f) Type %d WideSig %d\n
[GOTO] Align angle : %.1f (%.1f, %.1f, %.1f)\n
[GOTO] Reason Start, Dest : (%.1f, %.1f)\n
[GOTO] Reason Sensor\n
[GOTO] Reason F/W\n
[GOTO] Reason Complete\n
[GOTO] Reason Err:%d\n
Before SR(%d Points)\n
[GOTO] final via(%d points):\n
[GOTO] Dest(%3.1f %3.1f) -> (%3.1f %3.1f)\n
[GOTO] Changed Dest(%3.1f %3.1f) -> (%3.1f %3.1f)\n
[GOTO] Known Path\n
[GOTO] Known wf_repeat_cnt: %d wf_esc_cnt:%d\n
[GOTO PATH PLANNING TIME] t0~t1:%ld ms, t1~t2:%ld ms\n
[GOTO] SNG Homing\n
[GOTO] Known Overriding Path\n
[GOTO]  Overriding wf_repeat_cnt: %d\n
[GOTO] RobotPassed Overriding Path\n
[GOTO]  Overriding wf_repeat_cnt: %d, wf_esc_cnt:%d\n
[GOTO] (RobotPassed+Robot Can Passed) Overriding Path\n
[GOTO]  Overriding wf_repeat_cnt: %d wf_esc_cnt:%d\n
[GOTO] (RobotPassed+Robot Can Passed+Known) Overriding Path\n
[GOTO] UnKnown Path\n
[GOTO]  UnKnown Path: wf_repeat_cnt: %d\n
[GOTO PATH PLANNING TIME] t0~t3:%ld ms, t3~t4:%ld ms\n
[GOTO PATH PLANNING TIME]t0~t3:%ld ms, t3~t5:%ld ms\n
 >> [REAL SENSOR -> BUT VIA AGAIN:%d]\n
[GOTO] m_wf_dir:%d\n
[GOTO] m_rand_dist:%3.1f m_rand_ang:%3.1f\n
[GOTO] Left WF\n
[GOTO] Right WF\n
[GOTO] avoid planning fail : dir(%d)\n
[GOTO] Dist Sum Check:%3.1f\n
[GOTO] goto_planning_followwall_check SG\n
 >> [GOTO] follow_wall_info::EXCEPTION_SG , Make Pass]\n
 >> [GOTO] follow_wall_info::EXCEPTION_SG , Don't Make Pass]\n
[GOTO] followwall check planning fail : wf_dist_sum:%.1f, wf_ang_sum:%.1f wf_esc_cnt:(%d>=%d)\n
[GOTO] (d_sum(%.1f) > d_rand(%.1f)) (d_angle(%.1f) > d_rand(%.1f)) ang_diff %.1f ang_dest %.1f(via:(%d %d) ang_now %.1f\n
[GOTO]  wf_esc_cnt: %d\n
[GOTO] Make Path\n
[GOTO] Make MoveTo\n
[GOTO] Strange Case\n
[GOTO] A2N state : %d\n
%s dest=(%+7.0f,%+7.0f) opt_known=%d
%s goto_state=%d, reduce_obs_count=%d
make_path_goal_to_start_in_count_map
make_path_start_to_goal_in_count_map
find_large_margin_path
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/managing/task_subsys/planning/mx_path_planning.cpp
HEAD_SIZE violation!\n
min_value: %d\n
HEAD_SIZE violation(%d>%d)!\n
min_value %d\n
[KNOWN COUNTMAP](max:%d cur:%d)[%d]\n
[Size Check](max:%d cur:%d)[%d]\n
[PATH Plan] cur_search_count %d max_search_count %d SEARCH_MAP_SIZE %d\n
[OVERIDING COUNTMAP](max:%d cur:%d)[%d]\n
[RobotPassed](max:%d cur:%d)[%d]\n
[CountMap](max:%d cur:%d)[%d]\n
[Two Parallel](max:%d cur:%d)[%d]\n
[Four Point Line](max:%d cur:%d)[%d]\n
[Uncleaned](max:%d cur:%d)[%d]\n
under cell\n
Goal Area OK:i:%d,j:%d\n
[Global Overriding](max:%d cur:%d)[%d]\n
[Escape](max:%d cur:%d)[%d]\n
[Global Check](max:%d cur:%d)[%d]\n
[Inside Two Point](max:%d cur:%d)[%d]\n
(Goal Research!) NarrowGoal:(%d,%d)|
|POP(%d,%d)|
%d(%d,%d)|
OneEnd|
Path|
OneEnd(thresholded)|
OneDir_Full_Search End(%d)(%d,%d)|
OneDir_NoExtension|
(NarrowGoal:1st EndGoal :(%d,%d)|
(NarrowGoal:1st NOT_Found|
(NarrowGoal:2nd EndGoal :(%d,%d)|
(NarrowGoal:2nd NOT_Found|
|EXC_MAX_COUNT(%d)|\n
NOT Founded Extended Goal!-> USE Original Goal!\n
Finally founded!1_(%d, %d)\n
1st_NOT_FOUNDED!\n
Finally founded!1_(%d, %d)|
1st_NOT_FOUNDED!|
Finally founded!2_(%d, %d)
2nd_NOT_FOUNDED!\n
Finally founded!1(end_div2)(%d, %d)\n
Finally founded!1(thres)(%d, %d)\n
Finally founded!2(end_div2)(%d, %d)\n
Finally founded!2(thres)(%d, %d)\n
Selected:First|
Selected:Second|
 Goal is Moved to(%d, %d)\n
!!!!!!!!!!!!!!! finding goal !! UnderCell  !!!!!!!!!!!!!!!\n
Find 33 check under cell\n
Find Line under cell\n
Find 33 -> Re-search goal!\n
Use the Goal \n
Fail to Move the Goal \n
Cannot Find Goal under cell\n
GOAL CHECK:%d(1:LINE_GOAL_CAND, 3:NARROW_GOAL_CAND\n
==================================================\n
!!!!!!!!!!!!!!! finding goal !! NORMAL  !!!!!!!!!!!!!!!\n
Check  33\n
Find Line \n
Failt to move the Goal \n
Cannot Find a Goal \n
================================:%d\n
add_val_x:%3.1f %3.1f\n
add_val_y:%3.1f %3.1f\n
wall type %d\n
end_count %d\n
end_wall_count %d\n
dangerous_count %d\n
sector_wall_count %d\n
real_wall_count %d\n
empty_road.cell_3_count %d\n
empty_road.cell_2_count %d\n
Goal Check\n
Normal DEST[%d]:[%3.0f %3.0f]\n
Normal Find Goal()\n
Change Goal(%3.1f %3.1f) -> (%3.1f %3.1f)\n
Don't Find Goal -> Goal Find Again Use OverRiding Mask\n
Overiding DEST[%d]:[%3.0f %3.0f]\n
Overiding Find Goal()\n
Change Goal(OverRiding)(%3.1f %3.1f) -> (%3.1f %3.1f)\n
Don't Find Goal And Path\n
Only Check Goal, Change Goal(%3.1f %3.1f) -> (%3.1f %3.1f)\n
%d,
Point:[%d %d],[%d %d],[%d %d]\n
Remove Via:[%d %d]\n
Change Via:[%d %d]->[%d %d]\n
Find InterSectPoint:[%d %d] [%d %d] -> [%d %d]\n
| VIA(%d)_REMOVED!: (%d,%d)\n
>> start cell:(%d %d), goal cell:(%d %d)\n
>> SUCESS MAKE NEW COUNT MAP:GENERAL\t
>> MAKE HEAD SUCESS!!
>> MAKE VIA SUCCESS VIA=%d, robot(%d, %d), goal(%d, %d)(%.1f, %.1f)
-> VIA POINT[%d] = (%d, %d)
>> MAKE HEAD FAIL!!
>> SENSOR:%d %d %d(1:left,2:right)\n
>> USING SENSOR_1st:%d
>> KNOWN: USING MAP, ROBOT(%d %d), GOAL(%d %d)
>> KNOWN: USING MAP, PATH:angle:%3.1f,sensor_direction:%d, close_front:%d, wall_count:%d,wall_type:%d
CLOSE&RIGHT WF\n
CLOSE&LEFT WF\n
OPEN&LEFT WF\n
OPEN&RIGHT WF\n
LEFT WF\n
RIGHT WF\n
vector::_M_range_insert
\n[FIND OPTIMAL PATH] Find Original Path: Length(%d)\n
\n[FIND OPTIMAL PATH] Find Large Margin Path(CELL_WIDTH:%d)\n
[FIND OPTIMAL PATH] Length Condition OK(%d<(%d+%d)\n
\n[FIND OPTIMAL PATH] Don't Find Large Margin Path(CELL_WIDTH:0)\n
[FIND OPTIMAL PATH] Path Splitting\n
[FIND OPTIMAL PATH] Splitting(%d)[%d %d]->[%d %d]\n
[FIND OPTIMAL PATH] Need & Re-Planning(%d)\n
[FIND OPTIMAL PATH] Split Cell Extend:(CELLWIDTH:%d)\n
\n[FIND OPTIMAL PATH] Find New Path(:%d cell margin)\n
[FIND OPTIMAL PATH] Find Success\n
[FIND OPTIMAL PATH] New Via(%d %d)\n
[FIND OPTIMAL PATH] Extended Map Range(%d %d)~(%d %d)\n
[FIND OPTIMAL PATH] Current Pose is Goal Pose\n
\n[FIND OPTIMAL PATH] Reduce Via(%d times)->Size:%d\n
\n[FIND OPTIMAL PATH] Merge Cross Point\n
\n[FIND OPTIMAL PATH] Vias:(%d),Original Length(%d)\n
\n[USE ORIGINAL PATH] Vias:(%d),Original Length(%d)\n
[FIND OPTIMAL PATH] %s total:%ld ms\n
Count
Temp
Extended
HAS APPROACH ANGLE
NO  APPROACH_ANGLE
%s P=(%+6.0f,%+6.0f,%+4.0f) DIR=%+1.0f ARG=%3.0f %s FW_OPT=(%s) FW_COND=(%s) AO=%d SG=%d RO=%d VIA=%d(%d)
%s P=(%+6.0f,%+6.0f,%+4.0f) AO=%d RO=%d
GOANDTURN
%s Q=%+4.0f DIR=%+1.0f RO=%d
%s P=(%+6.0f,%+6.0f)      AO=%d RO=%d
%s P=(%+6.0f,%+6.0f,%+4.0f) DIR=%+1.0f AO=%d RO=%d
%s P=(%+6.0f,%+6.0f)      DIR=%+1.0f AO=%d RO=%d
%s P=(%+6.0f,%+6.0f)
MOVEBACK
%s P=(%+6.0f,%+6.0f,%+4.0f)
%s DIR=%+1.0f FW_OPT=(%s)
%s DIR=%+1.0f FW_OPT=(%s) FW_COND=(%s)
FOLLOWWALLSTOP
%s P=(%+6.0f,%+6.0f,%+4.0f) DIR=%+1.0f ARG=%3.0f
ROUNDTURN
%s %d %d AO=%d SG=%d (
[%d]=(%+6.0f,%+6.0f,%+4.0f,%3.0f,%d)
GOSTOP
TURNANDGO
TURNANDGOSTOP
%s P=(%+6.0f,%+6.0f,%+4.0f) S=(%s) FW_INFO=(%s) fw_result=%s
%s P=(%+6.0f,%+6.0f,%+4.0f) S=%s
SENSOR
%s P=(%+6.0f,%+6.0f,%+4.0f) FW_INFO=(%s)
%s P=(%+6.0f,%+6.0f,%+4.0f) FW_INFO=(%s) fw_result=%s
START
RESUME
TIMEOUT
FALSESENSOR
 \n\n\n\t\t >>>>>>>>>> accumulated angle : %.2f \n\n\n
\n\t\t >>>>>>>>>> follow wall stop by angle : %.2f \n\n\n
### Accum d_ang %.1f d_dist %.1f\n
Fail to getEdgeOpenStatus()\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
thread_priority    = %d\n
wait_start         = %d\n
wait_completed     = %d\n
sampling_time      = %d\n
sleep_time         = %d\n
thread_report      = %d\n
control_max_time   = %d\n
msglevel.disp_sync = %d\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
auto-planning
goto-planning
algorithm map-building time
FSM time
\n[TASK.NAV] Resetting map-building.\n
\n[TASK.NAV] Terminating state machine.\n
(%8ld)[TASK.NAV] TMB time: %d ms. (too long! >= %d)\n
(%8ld)[TASK.NAV] Initializing state machine.\n
[%6d] Command: %02X, %02X\n
(%8ld)[TASK.NAV] Pause SLAM by wheel lift.\n
(%8ld)[TASK.NAV] FSM tick event error! (%ld ms)\n
Received(%d, %d), Accepted(%d, %d), Running(%d, %d)\n
(%8ld)[TASK.NAV] FSM time: %d ms. (too long! >= %d)\n
N5boost16exception_detail10clone_implINS0_14bad_exception_EEE
N5boost16exception_detail10clone_implINS0_10bad_alloc_EEE
N5boost16exception_detail14bad_exception_E
N5boost16exception_detail10bad_alloc_E
St13bad_exception
St9bad_alloc
recv_handler_str
recv_handler_chr
boost::exception_ptr boost::exception_detail::get_static_exception_object() [with Exception = boost::exception_detail::bad_alloc_]
boost::exception_ptr boost::exception_detail::get_static_exception_object() [with Exception = boost::exception_detail::bad_exception_]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf2<int, mx_view, const void*, unsigned int>, boost::_bi::list3<boost::_bi::value<mx_view*>, boost::arg<1>, boost::arg<2> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf3<void, mx_view, tsock&, tsock&, int>, boost::_bi::list4<boost::_bi::value<mx_view*>, boost::arg<1>, boost::arg<2>, boost::arg<3> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf2<void, mx_view, tsock&, int>, boost::_bi::list3<boost::_bi::value<mx_view*>, boost::arg<1>, boost::arg<2> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf2<int, mx_view, tsock&, unsigned char>, boost::_bi::list3<boost::_bi::value<mx_view*>, boost::arg<1>, boost::arg<2> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf3<int, mx_view, tsock&, unsigned char*, unsigned int>, boost::_bi::list4<boost::_bi::value<mx_view*>, boost::arg<1>, boost::arg<2>, boost::arg<3> > >]
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/managing/task_subsys/mx_view.cpp
error!\n * tsock::open_server() returns %d (%s)\n
Opening %s (%s)
 * tsock::open_server_uds() returns %d (%s)\n
view socket
[VIEW] Socket accepted: %s\n
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/../Lib/Lib_Boost/include/boost/exception/detail/exception_ptr.hpp
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_nav, unsigned int>, boost::_bi::list2<boost::_bi::value<boost::shared_ptr<mx_nav> >, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_view, unsigned int>, boost::_bi::list2<boost::_bi::value<boost::shared_ptr<mx_view> >, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, task_subsys, int>, boost::_bi::list2<boost::_bi::value<task_subsys*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, task_subsys, void*>, boost::_bi::list2<boost::_bi::value<task_subsys*>, boost::arg<1> > >]
navigation
view
task thread
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_21thread_resource_errorEEEEE
N5boost16exception_detail10clone_implINS0_19error_info_injectorINS_10lock_errorEEEEE
N5boost16exception_detail19error_info_injectorINS_21thread_resource_errorEEE
N5boost16exception_detail19error_info_injectorINS_10lock_errorEEE
N5boost21thread_resource_errorE
N5boost10lock_errorE
N5boost16thread_exceptionE
Builder_Write2Main_Scube
set_rm_adv_info
boost::exception_ptr boost::exception_detail::get_static_exception_object() [with Exception = boost::exception_detail::bad_alloc_]
boost::exception_ptr boost::exception_detail::get_static_exception_object() [with Exception = boost::exception_detail::bad_exception_]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
boost::lock_error
boost::thread_resource_error
VIEW_LOG
%s: %s(%d) > \e[0;40;31msize:[%d]\n\e[0m
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/managing/task_subsys/view_impl.cpp
%s: %s(%d) > \e[0;40;31m[%02x]\n\e[0m
\e[36m[MAX]\e[m %02d:%02d:%02d.%06d
[sensor]%s,%s\n
[disp]%s,%s\n
[model_info]
[%02x]
[serial]%s\n
%s: %s(%d) > \e[0;40;31mRM_ADV_MODE_AUTO:[%d][%d][%d][%d][%d]\e[0m
%s: %s(%d) > \e[0;40;31mRM_ADV_MODE_HOMING:[%d]\e[0m
%s: %s(%d) > \e[0;40;31mRM_ADV_MODE_DOCKING:[%d][%d]\e[0m
draw
moving
cancel
@STS
%02d:%04d
Token
Allow
@CMD
%02d
@OTN
CHECK
FORCE
INFO
RMSTOP
dbmain
5%c%c%c%c%c%02x
db/rvc/assym
db/rvc/assymv
dbsensor
db/rvc/assys
db/rvc/assysv
dbdisp
db/rvc/assyd
db/rvc/assydv
DJ92-%c%c%c%c%c%c,%02x%02x%02x%02x
modelup
%02x%02x%02x%02x%02x%02x%02x%02x
db/rvc/group_info_upper
modellow
db/rvc/group_info_lower
serialupper
%c%c%c%c%c%c%c%c
db/rvc/serial_upper
seriallower
%c%c%c%c%c%c%c
db/rvc/serial_lower
realtime
20%02d,%02d,%02d,%02d,%02d,%02d
noti
spause
stopped
auto
repeat
part
manual
schedule
creating
return
failed
idle
charge
reserve
setclock
setreserve
after
point
pause
mpause
facmode
poweroff
effect
mute
voicew
voicem
{"clean":"%s","drive":"%s","turbo":"%s","smart":"%s","power":"%s","sound":"%s","battery":"%d","remote":"%d","otn":"%d","err":"%d","repeat":"%s","reserve":"%s,%s,%02d,%02d","daily":"%s,%s,%02d,%02d"}
steer
AREA
reboot
update
MASTER
power
daily
clock
wifi
ApOn
ApOff
turbo
silence
smart
drive
forward
left
right
homing
scube
rminfo
rmmac
dbinfo
main
display
modelFront
modelEnd
serialFront
serialEnd
Unexpected packet size received = %d\n
%%%ds
%d %d %d %d
%lld
clean.txt
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
### print_back #%d\n
###cleaning_triger #1\n
/opt/data/robot-network/files/master.fp
###cleaning_triger #2\n
###cleaning_triger #3 %d\n
###cleaning_triger #4 %d\n
### get_room_position #%d\n
### get_room_position #%d failed \n
### is_door_near #%d\n
### is_door_near case#1 door_p1 [%d,%d] door_p2 [%d,%d] cnt_door [%d,%d] r_cell[%d,%d] dist: %d\n
### is_door_near case#2 \n
### is_door_near case31 door_p1 [%d,%d] door_p2 [%d,%d] cnt_door [%d,%d] r_cell[%d,%d] dist: %d\n
### is_door_near #%d failed \n
### before clear_one_room #%d, size %d\n
### after clear_one_room #%d, size %d\n
### after clear_one_room empty\n
### BL1_ex2: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### BL1_ex1: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### BL1: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### BL4_ex2: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### BL4_ex1: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### BL4: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### BL3_ex2: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### BL3_ex1: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### BL3: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### BL2_ex2: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### BL2_ex1: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### BL2: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### Door_L1: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### Door_L4: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### Door_L3: [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### door: ORG[%d %d, %d %d], [%d %d] => [%.1f %.1f], [%d %d] => [%.1f %.1f]\n
### can't get_room_index #%d\n
 * [erase_gate_map] min(%+3d,%+3d), max(%+3d,%+3d)\n
/opt/data/robot-network/files/
acm r: %d, sts: %d %d\n
###set_area_cleaning_status_forced #1 %d\n
acm r: %d, sts: %d\n
no setting status forced\n
acm r: %d, sts: %d, tmp_sts: %d, r_id %d\n
###reset_all_cleaning_status #1\n
###reset_all_cleaning_status #1 %d\n
0123456789
Exiting Successfully.\n
Exiting Erroneously.\n
parse
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf0<int, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<bool, boost::_mfi::mf1<bool, status_subsys, int>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<int> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, status_subsys>, boost::_bi::list1<boost::_bi::value<status_subsys*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const pose&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<pose> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, status_subsys, const rm_adv_info&>, boost::_bi::list2<boost::_bi::value<status_subsys*>, boost::_bi::value<rm_adv_info> > >]
sig_hup
sig_int
Device Interface
mx_device
Status Subsystem
status_subsys
Mobility Subsystem
mobility_subsys
Task Subsystem
task_subsys
Console Subsystem
console
[UATLAS] CONFIGURATION MISMATCH!!
 * MICOM == NXP_BOARD but device.pibo = %d, device.nxbo = %d\n
Parsing configuration file '%s'...\n
default.conf
current.conf
Done. (%d parameters are loaded and converted in %ld ms.)\n\n
Error! (Can't open configuration file.)
Using default configuration.
(%d parameters are converted in %ld ms.)\n\n
\rpress ENTER to use console mode...%%-%dd
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/managing/uatlas_subsys/uatlas.cpp
_getch_nolock() returns %d (0x%0X).\n
_kbhit() returns nonzero value.\n
 * argv[0]        : %s\n
 * image_pathname : %s\n
 * image_dirname  : %s\n
 * image_basename : %s\n
/tmp/%s
uatlas::parse end
uatlas::parse() error! Exiting...
Can't capture SIGHUP
uatlas::update_param() error! Exiting...
** Aborting Program!! **\n
uatlas::init() error! Exiting...
uatlas::run() error! Exiting...
uatlas::stop() error! Exiting...
uatlas::exit() error! Exiting...
OS build number: %ld\n
Samsung MAX-RVC Control Program %d.%d (revision %s %s %s)\n
Copyright (c) 2011-2012 Samsung Electronics Co., LTD.
Restarting....\n
Could not restart\n
[ E X I T ]
::exit end
%s \n
\n\n[ S T O P ]
::stop end
[ R U N ]
::run end
[UATLAS] System Information:
 * Model Name  :    %s\n
 * OS build No.:    %ld\n
 * SW GIT revision: %04x\n
 * SW build time:   %d-%02d-%02d %02d:%02d:%02d\n
 * SW build config: %s\n
 * OS/SW Update:    %s\n
/tmp/robot-main-ver.log
/tmp/robot-main-ver.log open failed
[UATLAS] Memory Usage:
 * Total physical memory : %8lld Kbytes\n
 * Free  physical memory : %8lld Kbytes\n
 * Total virtual  memory : %8lld Kbytes\n
 * Free  virtual  memory : %8lld Kbytes\n
[UATLAS] CPU Usage:
 * CPU currently used: %5.2f percent.\n
 * CPU currently used by this process: %5.2f percent.\n
[UATLAS] Initialization Time:
 * uatlas::parse()                 : %ld ms\n
 * uatlas::update_param()          : %ld ms\n
 * uatlas::init()                  : %ld ms\n
 * uatlas::run()                   : %ld ms\n
 * from beginning to device::run() : %ld ms\n
 * from beginning to uatlas::run() : %ld ms\n
[ I N I T ]
::init end
::update_param end
sig = %d\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, res<mx_board_cmd, mx_board_sts>, void*>, boost::_bi::list2<boost::_bi::value<res<mx_board_cmd, mx_board_sts>*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_device, int>, boost::_bi::list2<boost::_bi::value<mx_device*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_sound_play, unsigned int>, boost::_bi::list2<boost::_bi::value<mx_sound_play*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_device, unsigned char*>, boost::_bi::list2<boost::_bi::value<mx_device*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, mx_device, void*>, boost::_bi::list2<boost::_bi::value<mx_device*>, boost::arg<1> > >]
(%8ld)[DEVICE    ] wcam_grab() -> m_wcam_grab_callback()\n
Removing %s (addr=0x%08x)
sound-play
[DEV] Play sound: %s\n
board resource
done. (addr=0x%08x)\n
motor resource
sensor resource
ui resource
device thread
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf0<void, mx_device_serial>, boost::_bi::list1<boost::_bi::value<mx_device_serial*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, mx_device_serial, void*>, boost::_bi::list2<boost::_bi::value<mx_device_serial*>, boost::arg<1> > >]
[DEV.SER] First packet received: %ld ms after beginning.\n
[DEV.SER] Invalid data received!\n
[DEV.SER] Unexpected packet received!\n
[DEV.SER] Packet receive timeout!\n
[DEV.SER] General error!\n
%4ld (%4ld, %4ld, %4ld, %4ld, %4ld, %4ld, %4ld, %4ld)
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
pibo serial
[%6d] PACKET_REP_NA report:\n
[%6d] PACKET_CTL_AN report:\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
nxbo serial
recv
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf1<int, mx_serial, unsigned char>, boost::_bi::list2<boost::_bi::value<mx_serial*>, boost::arg<2> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, boost::_mfi::mf2<int, mx_serial, unsigned char*, int>, boost::_bi::list3<boost::_bi::value<mx_serial*>, boost::arg<2>, boost::arg<3> > >]
_deinit
mx_packet::compose() returns %d!\n
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/resource/device_subsys/mx_serial.cpp
rc = %d\n
CALL
mx_serial::print_send_buf() (m_send_buf_len = %d)\n
%02X
  %-33s=%8d  %-20s=%8d\n
TOTAL RECEIVED
TOTAL SENT
  ------------------------------------------
  -----------------------------\n
  %-33s=%8d
RECV_STATE_OK
RECV_STATE_ERR_GENERAL
RECV_STATE_ERR_TIMEOUT
RECV_STATE_ERR_UNEXPECTED_PACKET
RECV_STATE_ERR_DECOMPOSE
RECV_STATE_TOO_SHORT_PKT_LEN
RECV_STATE_TOO_SHORT_BUF_LEN
RECV_STATE_INVALID_PKT_LEN
RECV_STATE_SOH_NOT_FOUND
RECV_STATE_INVALID_PKT_ID
RECV_STATE_PKT_LEN_MISMATCH
RECV_STATE_DISCONT_COUNT
RECV_STATE_CHKSUM_MISMATCH
Removing %s
Closing %s (%s,%s,%d,%d)
 * mx_serial::close() returns %d (%s)\n
 * mx_serial::open() returns %d (%s)\n
[chksum mismatch] %s, True Checksum: %02X\n
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, res<mx_motor_cmd, mx_motor_sts>, void*>, boost::_bi::list2<boost::_bi::value<res<mx_motor_cmd, mx_motor_sts>*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(const char*, _IO_FILE*), boost::_bi::list2<boost::arg<1>, boost::_bi::value<_IO_FILE*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<int, int (*)(_IO_FILE*), boost::_bi::list1<boost::_bi::value<_IO_FILE*> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, mx_ol_processing, void*>, boost::_bi::list2<boost::_bi::value<mx_ol_processing*>, boost::arg<1> > >]
(%8ld)[OL_CAL_PROC] Cam is not ready\n
(%8ld) change cam register fail \n
(%8ld)[OL_PROC   ] Waiting  grab event\n
(%8ld)[OL_PROC   ] Received grab event\n
(%8ld)[OL_PROC   ] Last buffer index = %d\n
\nOL_Sensor_Performance [%d]\n
     t1_time\tt2_time\t\tcapture_time\t\t:\twild_time\twf_time\t\t:\tthread_time\n
avg: %6.3lf\t%6.3lf\t\t%6.3lf\t\t\t:\t%6.3lf\t\t%6.3lf\t\t:\t%6.3lf\n
std: %6.3lf\t%6.3lf\t\t%6.3lf\t\t\t:\t%6.3lf\t\t%6.3lf\t\t:\t%6.3lf\n
min: %6.3lf\t%6.3lf\t\t%6.3lf\t\t\t:\t%6.3lf\t\t%6.3lf\t\t:\t%6.3lf\n
max: %6.3lf\t%6.3lf\t\t%6.3lf\t\t\t:\t%6.3lf\t\t%6.3lf\t\t:\t%6.3lf\n
[WiLD] Camera On\n
[WiLD] Camera Off\n
(%8ld)[OL_PROC   ] capture_image error!\n
(%8ld)[OL_PROC   ] wild_grab_loop() -> m_wcam_grab_callback() : %08X\n
Initializing Omni-laser sensor:
[WiLD] initializing time = %ld msec\n
[WiLD] Already initialized!\n
[WiLD] Error!\n
[WiLD] Error! (Initialize Grabber)\n
[WiLD] Error! (Enable Camera)\n
[WiLD] Error! (GPIO)\n
[WiLD] Error! (Parameter)\n
/opt/app_rw/css_camtest_plus_jpg_socket
/opt/app_rw/css_camtest_plus_jpg_socket &
[WiLD] css_camtest_plus_jpg_socket start!!\n
[WiLD] can not fild css_camtest_plus_jpg_socket!!\n
wild-grab thread
control
pre_control
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_sensor_res, unsigned char*>, boost::_bi::list2<boost::_bi::value<mx_sensor_res*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void, boost::_mfi::mf1<void, mx_ol_processing, int>, boost::_bi::list2<boost::_bi::value<mx_ol_processing*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, res<mx_sensor_cmd, mx_sensor_sts>, void*>, boost::_bi::list2<boost::_bi::value<res<mx_sensor_cmd, mx_sensor_sts>*>, boost::arg<1> > >]
/home/abuild/rpmbuild/BUILD/robot-main-1.0/RVC/MaxRVC/resource/sensor_res/mx_sensor_res.cpp
...%.5d\n
(%8ld)[RES.SENSOR] wcam_grab() -> m_wcam_grab_callback()\n
omni-laser-processing
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
static const char* boost::detail::sp_typeid_<T>::name() [with T = boost::_bi::bind_t<void*, boost::_mfi::mf1<void*, res<mx_ui_cmd, mx_ui_sts>, void*>, boost::_bi::list2<boost::_bi::value<res<mx_ui_cmd, mx_ui_sts>*>, boost::arg<1> > >]
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
[Ceiling Read] eeprom_create fail [%x]
[Ceiling Read] eeprom_prepare fail [%x]
 [Ceiling Read] EEPROM chksum error! T: %0X, F: %0x, retry_read_cnt: %d\n
[Ceiling Read] eeprom_unprepare fail [%x]\n
[Ceiling Read] eeprom_destroy fail [%x]\n
 [Ceiling Read] cam_param_write failed!
Camera
optX
optY
camX
camY
principal_pt_XY
%f, %f
Loading debug parameter...
server     = %d\n
use_cvslam = %d\n
use_idle   = %d\n
use_frontV = %d\n
use_gas    = %d\n
autoreloc  = %d\n
Done.
_ErrorAlert1 = %d\n
%s%s
GridSize
Checking parameter file(%s)...\n
  cam_param.ini DOES NOT exist, default one will be generated!
Error!. (file not exists)
Error!. (calibration error, optX=160 and optY=120)
Error!. (missing parameters)
  cam_param.ini is wrong, default one will be generated!
/tmp/cam_param.ini
/tmp/
/opt/data/rvc/
cam_param.ini
Initializing FCA(x = %3d, y = %3d, ratio = %f, scale = %f)...
Localizer Init Failed
Localizer Init OK
\nInitializing localizer server...
Error! (code = %d)\n
/usr/apps/rvc/atan.tbl
/opt/data/rvc/atan.tbl
TransmitImage
CLocalizerThread
CCoordinate
CameraCalibration
FindCeilingAngle
static const char* boost::detail::sp_typeid_<T>::name() [with T = void]
##### [linux_cvslam] %.1f %.1f %.1f %.1f %.1f\n
\n--------------------------------------------------------------------------------
[SLAM] CCVSlamAutobotWrapper::Initialize()\n
\n[SLAM] CCVSlamAutobotWrapper::Initialize() returns %d (%ld ms)\n
--------------------------------------------------------------------------------\n
[Ceiling CAL]eeprom_write fail !!!\n
 [Ceiling CAL] Success!\n
[Ceiling CAL] eeprom_unprepare fail [%x]\n
[Ceiling CAL] eeprom_destroy fail [%x]\n
[Ceiling CAL] eeprom_write fail !!!\n
[CameraCalibration](DMCSLAM)\n
[CameraCalibration] change camrea register failed\n
/tmp/robot_ceiling_img.yuv
cannot open /tmp/robot_ceiling_img.yuv\n
/tmp/cal_wrt_fail.bmp
/tmp/ccd_wrt_fail.bmp
Camera Calibration Writing Fail!!\n
/tmp/robot-main-cal.log
cannot open /tmp/robot-main-cal.log\n
/tmp/cal.bmp
/tmp/ccd.bmp
Camera Calibration Success!!\n
[Camera] optX = %f\n
[Camera] optY = %f\n
[Camera] PrinciapX = %f\n
[Camera] PrinciapY = %f\n
/tmp/ccd_cal_fail.bmp
Camera Calibration Fail!!\n
Transmit Ceiling Image After Camera Calibration\n
Transmit WiLD Image\n
/opt/app_ro/txWiLDImg
failed to save WiLD Image!!\n
(Slam Cal.) img_acq.:%.3f ms, calibration:%.3f ms, save_img:%.3f ms\n
(Cal. Total) slam:%.3f ms, wild_img trans.:%.3f ms (Total: %.3f ms)\n
Cannot Open %s\n
Excedd MaxSize in Reading Line
Token is over than 255
Char Size Error in Reading %s (data = %s) (size = %d)\n
  %s: %s = %s\n
Cannot Find [%s] %s in %s\n
  %s: [%s] %s = %s\n
Fail to fseek()
Fail to fread()
%s=%s\n
[CSingleThread] [%30s] [ID:%8d] Thread Stop Wait\n
[CSingleThread] [%30s] Thread Create error\n
[CSingleThread] [%30s] [ID:%8d] Thread Started\n
[CSingleThread] [%30s] [ID:%8d] Thread Stopped\n
Error mutex lock error [%s]\n
Error mutex unlock error [%s]\n
[CClientSock:%s] Socket Close\n
[CClientSock:%s] Start Recv\n
[CClientSock:%s] Recv time out [%d msec]\n
[CClientSock:%s] Detect socket error, socket will be closed\n
[CClientSock:%s] Detect socket close\n
[CClientSock:%s] Socket is closed manually\n
[CClientSock:%s] Recv Callback is NULL\n
CClientSock
%s:CClientSock
[TCPPacket][SockSendData] send error [%d]\n
Close Error[0x%08x]\n
hostName size over in nameToAddr()!
EBADF
EFAULT
ENOTSOCK
EISCONN
EINPROGRESS
UNKNOWN
host name not found
Socket connection error[%d][%s]\n
select error
sock select error[%s]\n
connectin closed
socker read error[%s]\n
%02X
###m_recordFile fclose
CSingleSock CellMap Construction
CSingleSock etc Construction
%sdebug%03d.rec
Can't open the file : %s \n
FF%02d\n
###m_recordFile is OK
##%s is not available\n
[CServerSock  ] [%d] Socket Creation Fail\n
[CServerSock  ] [%d] Socket Creation Success\n
[CServerSock  ] [%d] Socket handle is NULL. thread will stop\n
[CServerSock  ] [%d] Sever Socket Closed\n
[CServerSock  ] [%d] Client Socket Accepted[%d]\n
[CServerSock  ] [%d] Failed to Accept Socket\n
%s:CServerSock
CServerSock
/opt/app_conf/rDist.tbl
Camera Calibration Success!!
Enable Local Relocation [%s]\n
Forced SLAM run : encoder stack is almost full(over 80%%)\n
VipArrAlloc() returns 0! %s:%d\nExiting program!\n
/home/addict1/Project/VR9200J_UNIVISION/CVSlamLocalizerDMC/source/../Lib_common/Vip/include/VipArray.h
SlamParam
dstVar
angVar
driftVar
shiftVar
particle_number
fwd_variation1
ang_variation1
dist_variation1
fwd_variation2
ang_variation2
dist_variation2
variation_count1_building
variation_count2_building
variation_count1_using
variation_count2_using
lm_covariance_range_x
lm_covariance_range_y
lm_covariance_range_z
odo_rotation_thres_deg
robot_DiffAngDeg_RotThres
lm_rem_wrong_cnd_3Dpos_dist
lm_rem_cnd_3Dpos_near_dist
lm_rem_corner_near_dist
cand_update_dist
lm3D_register_min_angle1
lm3D_register_min_angle2
lm3D_register_min_z
lm3D_register_max_z
lm3D_remove_min_z
lm3D_remove_max_z
lm3D_register_min_angle_light1
lm3D_register_min_angle_light2
lm3D_register_min_z_light
lm3D_register_min_lm
lm3D_register_count
slam_count_building
slam_count_using
map_using_lm_update
covsum_converged
covsum_small
remove_cov
flat_ang_l_thres1
flat_cnf_thres1
flat_ang_l_thres2
flat_cnf_thres2
pos_reassign_CNF_thres
multipatch_add_margin
multipatch_dist
use_corner_direction
corner_direction_margin_deg
corner_direction_weight
measure_dist_cov_coeff
measure_ang_cov_deg
sq_sum_change_thres_low
sq_sum_change_thres_high
near_landmark_disable_thres
max_enabled_lmk_num
lmk_initial_dir_min_cov
lmk_initial_dir_max_cov
lmk_initial_dist_min_cov
lmk_initial_dist_max_cov
lmk_initial_ang_min_cov
lmk_initial_ang_max_cov
search_corner_NCC_range_low
search_corner_NCC_range_high
lm_converged_number
lm_range_variance_ratio
hyst_count
lm_matched_low_lm
lm_matched_high_lm
slip_particle_range_x
slip_particle_range_y
slip_particle_range_z
slip_lm_range_low
slip_lm_range_high
slip_variable_range_low_x
slip_variable_range_high_x
slip_variable_range_low_y
slip_variable_range_high_y
slip_variable_range_low_z
slip_variable_range_high_z
var_dist
var_ang
calib_pose_lm_particle_num
calib_pose_lm_iter_num
calib_pose_lm_angle_count
slip_first_grid_num_x
slip_first_grid_num_y
slip_first_grid_num_z
slip_second_grid_num_x
slip_second_grid_num_y
slip_second_grid_num_z
slip_grid_width_x
slip_grid_width_y
slip_grid_width_z
slip_grid_width_mul
slip_grid_iter_num
slip_grid_penalty_bias
slip_grid_penalty_mul_x
slip_grid_penalty_mul_y
slip_grid_penalty_mul_z
calib_pose_lm_converged_only
use_angle_change
varpose_thr
pfdist_thr
pfdist_thr_min
f_calceff_thr
err_ori_thr1
err_ori_thr2
pos_err_diff_thr1
pos_err_diff_thr2
ang_err_diff_thr
use_pos_diff_thr
use_ang_diff_thr
err_slip_min_lm
err_slip_count
slip_particle_delay
use_light_source
light_source_weak_thres
light_source_weak_num_thres
light_source_strong_thres
light_source_strong_num_thres
light_source_range
light_measure_dist_cov_coeff
light_measure_ang_cov_rad
light_filter_weight_coeff
relocal_range
lm_relocal_range
make_min_particle
make_max_particle
converge_thres_max
converge_thres_particle_size
converge_thres_dev_scale
converge_thres_dev_size
converge_thres_scale_hi
particle_std_thresh
particle_std_thresh_lo
remain_particle_var_dist_thresh
remain_particle_var_ang_thresh
minimum_size
wide_resampling_max_count
wide_thresh_dist
wide_thresh_ang
narrow_resampling_max_count
wide_fine_cal
narrow_fine_cal
use_breaking_loop
resample_threshold_low
resample_threshold_mid
resample_threshold_high
useGyroInfo
gyroThresh
corner_barrier_low
corner_barrier_high
corner_normalize
line_lm_covariance_range_x
line_lm_covariance_range_y
line_lm_covariance_range_z
line_lm_rem_wrong_cnd_3Dpos_dist
line_lm_rem_line_near_lm_dist
line_lm_rem_line_near_lm_ang_deg
line_lm3D_register_min_z
line_lm3D_remove_min_z
line_covsum_converged
line_covsum_small
line_remove_cov
line_pos_reassign_CNF_thres
line_cnf
line_cnf_delta
line_measure_dist_cov_coeff
line_measure_ang_cov_deg
line_sq_sum_change_thres
line_near_landmark_disable_thres
line_search_corner_NCC_range
line_comp_angle_thres_deg
max_border_anchor_num
max_mid_anchor_num
center_margin_radius
b_line_num_thres
line_check_edge_thres
ef_std_thres
border_anchor_edge_thres
mid_anchor_edge_thres
border_anchor_point_count_thres
mid_anchor_point_count_thres
ef_insert_thres
ef_insert_diff_thres
ef_ang_diff_thres
RANSAC_line_min_length_thres
ef_init_count_max
ef_check_count_max
ransac_make_sample_dist_thres
ransac_dist_thres
ransac_cost_thres_ratio
ransac_stop_ratio
ransac_dist_out_mean_thres
ransac_base_l_pt_num
ransac_max_iteration_num
line_check_mh_dist_thres
line_check_pt_line_dist_thres
line_check_inner_following_dist_thres
line_check_inner_std_thres
line_check_follow_length
line_check_init_std
line_check_end_std
line_replace_minDistH_thres
use_grabber_thread
grabber_thread_priority
sleep_time_camera_off
sleep_time_rotation_false
sleep_time_rotation_true
msglevel_slampf
msglevel_slampf_slip
msglevel_slampf_slip_dist
  No principal_pt param! Using optCenter (%3.1f, %3.1f)\n
ss_order
invpol
rDist
ReLoad Camera Param Fail.
ReLoad Camera Param OK.
Saving rDist.tbl is completed.
[CamParam Check] CamParam is not properly generated!
/opt/app_conf/cam_param.ini
[LIB] SLAM version : %d.%d.%d\n
[LIB] SVN revision : %d\n
[LIB] BOARD_VERSION  = %s\n
[LIB] CAMERA_MODEL   = %s\n
WE970
[LIB] USE_RELOCATION = %d\n
[LIB] USE_UNIVISION  = %d\n
[LIB] DEBUG_MESSAGE  = %d\n
[LIB] Loading camera parameter...
[LIB] CamPos [%3.1f %3.1f %3.1f]\n
[LIB] Done.
[LIB] Loading debug parameter...
[LIB] Error! (m_bCamParamError = true)
[LIB] Loading tuning parameter...
Tuning
[LIB] Initializing localizer parameter...
[LIB] Initializing camera...done.
[LIB] Loading SLAM parameter...
[LIB] Checking camera parameter...
error! (m_bCamParamError = true)
_RelocationLocal()
m_robotPose.x:%f,.y:%f , pose.x:%f,.y:%f\n
Failed
[LIB] Grab error! (%d)\n
m_csVar
CCVSLAMLocalizer
CVSlamCtrl_IF
CVSlamCtrl_interface:Grab
Localizer_Thread
[jpeg size]%d\n
[jpeg data]
Invalid m_eLocalizationMode=%d!\n
Camera clock enable false
Camera is not opend
vector::_M_insert_aux
Camera clock enable true
i2c_write_ceiling(SLAM/Grabber) %s\n
ccamreg.dat
%02X %02X
\n- Write fail.. -
file close error.. (return val=%d)\n
Camera is not opened
cvs_Localizer
param1
param2
cov_index
VSlamServer:3DMap
VSlamServer:2DImg
VSlamServer:SendData
VSlamServer:SendImag
Stream_Queue
Queue Is Full!, Delete First One
S[0]S[3]-S[1]S[2]=0
WRONG CASE:_GenerateDebugInfo
[MLocalizer] m_arrPoseCluster size = %d\n
REMOVE DECREASE WEAK LM
index overflow! (m_arrLmk3DPos)
index overflow! (m_arrCnd3DPos)
index overflow! (m_arrCorner_bef)
index_out overflow! (m_arrCorner)
*****MLocalizer::pub_StreamMap
m_arrLmk3DPos size = %d\n
REMOVE WEAK LM
Success
[MLocalizer] CheckSlip[%6s] : d:%5.2f, angle = %5.2f, Size:%d\n
Pose[%.1f,%.1f,%f]
Cnt[%03d][Max:%d:%d:%04.2f]
Relocation Success [%d]\n
Pose Candidate Size is zero
WRONG CASE:_CheckDescriptor
WRONG CASE:RemoveCnd3DPosNearLM
WRONG CASE:RemoveWrongCnd3DPos
IsMemBlockEmpty?
WRONG CASE:_RegisterNewLmk3DPos
REMOVE WEAK LANDMARK!!!
DECREASE LANDMARK!!!
DECREASE MEMBLOCK!!!
\a\a\a\a\a\a\a\a\a\a\a\a\a\a\a\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\b\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\v\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\f\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r\r
\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e\e
                                                                 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""""#######################################################################$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&'''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''''((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((((()))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))*************************************************************************************+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,-------------------------------------------------------------------------------------------.............................................................................................///////////////////////////////////////////////////////////////////////////////////////////////0000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111111222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222222223333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333333444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444444555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555555556666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666666777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777777888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888888889999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999:::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::::;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<===========================================================================================================================>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>???????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????????@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDDEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGG
GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHHIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIIJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJJKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKKLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLLMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMMNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNNOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPPQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQQRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRRSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSSTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTTUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVVWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWWXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYYZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^______
_________________________________________________________________________________________________________________________________________________________________________________________`````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````````aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccccdddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeefffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggggghhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiiijjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjjkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkkklllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllllmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnnooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooooopppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppppqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrr
rrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrrssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssssstttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttttuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvvwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwwxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyyzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzzz{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{|||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
[CMemBlock] %dkb are Allocated\n
LM:%d\n
dist:%f\n
prjDIr:%f\n
arrDir:%f\n
diffAngleH:%f\n
cnf:%f\n
LMnum:%d pose %d %d %d\n
A%d particles are removed. \n
  FindLMMinDistError
    (%+6.1f,%+6.1f,%+6.1f) (%+6.1f,%+6.1f,%+6.1f) = %6.1f (%6.1f, %6.4f)
 ****
distSum=%6.1f Pose=(%+6.1f, %+6.1f, %+6.1f)\n
Seed.P=(%+7.1f, %+7.1f, %+6.1f) Min.Grid=(%+d, %+d, %+d) P=(%+7.1f, %+7.1f, %+6.1f) Delta=(%+6.1f, %+6.1f, %+6.1f)\n
MIN (%+6.1f,%+6.1f,%+6.1f) (%+6.1f,%+6.1f,%+6.1f) = %6.1f (%6.1f, %6.4f)\n\n
CalibratePoseByLM2
(%f, %f, %f)\n
Effective Landmark Size*Particle:%d\n
Observe Error=%f Distance Error=%f\n
SLAM RESET
m_light_measure_cov_coeff(Dist=%f, Ang=%f, FilterW=%f)\n
CSlamPF
nConvergedLMCnt:%d bUseVSC:%d bLockUpdate:%d\n
Normalize Fail > ResetParticleWeight
VSC Before:[%3.1f %3.1f %3.1f] -> After:[%3.1f %3.1f %3.1f (%3.1f)]\n
VSC:%d m_nLMEnabled:%d\n
No High Weight Particle
m_minWeightP:%d m_maxWeightP:%d\n
OUT:[%3.1f %3.1f %3.1f]\n
[%5d] Slip Compensation: errNew=%5.2f nCLM=%2d\n
  Position(rel. to max. weight particle)=(%+6.1f,%+6.1f,%+6.2f), Sum(%5d)=(%+7.1f,%+7.1f,%+7.2f)\n
errOri=%4.1f errNew=%4.1f\n
regRobot=(%+6.1f,%+6.1f,%+6.1f) degRobot=(%+6.1f,%+6.1f,%+6.1f)\n
[%5d] CalcEff(%4.1f<%4.1f) -> _ResampleQueue, ResetParticleWeight (%4d)\n
[%5d] CalcEff(%4.1f<%4.1f) -> ReplaceWeakParticle %d/%d (%4d)\n
[%5d] m_varPose=%5.1f>%5.1f, PFdist=%4.1f>%2d, init_cnt=%2d -> Initialize Particle (%4d)\n
[%5d] m_varPose=%5.1f>%5.1f, PFdist=%4.1f>%2d, init_cnt=%2d -> ReplaceWeakParticle %d/%d (%4d)\n
./optcenter.txt
File open error! (./optcenter.txt)
stack
CStackDataData::Add Warnning!!! encoder stack is full
Z == 0 DIVISION BY ZERO!!!!
preZ == 0 DIVISION BY ZERO!!!!
dd < 0 ASSERTION ERROR!!!!
GRAY
[LIB] Loading Atan2 Table (%s)...
done. (%.3f ms)\n
[LIB] Generating Atan2 Table...
[LIB] Saving Atan2 Table (%s)...
error!.
[CSingleThread] %30s (id=%3d) Thread Started\n
[CSingleThread] %30s (id=%3d) Thread Stopped\n
\nid %d setpriority(%d) error!\n
[CSingleThread] %30s (id=%3d) Thread Stop Wait\n
%s: [%s] %s = %s\n
Exceeded MaxSize in Reading Line!
Cannot Open %s
This function has to be used for parameters >1 !!!
  %s: %s =
/home/addict1/Project/VR9200J_UNIVISION/CVSlamLocalizerDMC/Lib_common/Oil/include/Oil_Network/../../../Vip/include/VipArray.h
Jpeg
malloc() returns 0! %s:%d\nExiting program!\n
/home/addict1/Project/VR9200J_UNIVISION/CVSlamLocalizerDMC/Lib_common/Oil/include/Oil_Vision/JpegWrap.cpp
error! (Invalid type %d)\n
error! (Version: expected=%d, read=%d)\n
error! (Type: expected=0 or 1, read=%d)\n
error! (Different camera parameters)
error! (File size: expected=%d, read=%ld)\n
Loading Radial Distortion Table (%s)...
error! (CANNOT open (%s))\n
[LIB] Generating Radial Distortion Table...
 - Inverse Model...
 - Forward Model...
[LIB] Done. (%.3f ms)\n
connection closed
socker write error[%s]\n
1 0 0 ; 0 1 0 ; 0 0 1
%s.%s
%s_%d.%s
  %e
(%8ld) [%-30s] : %10ld (%6ld) %s\n
Windows bitmap (*.bmp;*.dib)
JFIF
JPEG files (*.jpeg;*.jpg;*.jpe)
JFIF
1H\v\f\r
#@\\\n
%7N_
8@Wb
(3DQgp(:9Wmhyd3<EPgqxg=78>M\\ec
/cccc
Bcccc
8ccccc/Bcccccccccccccccccccccccccccccccccccccc
\e")081*#
$+29:3,%
&-4;<5.'/6=>7?????????????????
\a\b\t\n\v
AQ\aaq
\t#3R
&'()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz
Qa\a"q
$3br
%&'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz
\a\b\t\n\v
P%c\n%d %d\n255\n
Portable image format (*.pbm;*.pgm;*.ppm)
Sun raster files (*.sr;*.ras)
TIFF Files (*.tiff;*.tif)
AQ\aaq
\t#3R
&'()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz
Qa\a"q
$3br
%&'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz
\a\b\t\n\v
\a\b\t\n\v
/cccc
Bcccc
8ccccc/Bcccccccccccccccccccccccccccccccccccccc
(3=\f\f
(9E8
3WP>
%8DmgM
#7@Qhq\\1@NWgyxeH\\_bpdgc
E\v0~
sAmTb
BKbhTb~XBK!;
A!;I2
"\v0A-
E\v0~
sAmTb
BKbhTb~XBK!;
A!;I2
"\v0A-
!(0)"\e
#*1892+$
%,3:;4-&
'.5<=6/7>?????????????????
s message code %d
Sorry, there are legal restrictions on arithmetic coding
ALIGN_TYPE is wrong, please fix
MAX_ALLOC_CHUNK is wrong, please fix
Bogus buffer control mode
Invalid component ID %d in SOS
DCT coefficient out of range
IDCT output block size %d not supported
Bogus Huffman table definition
Bogus input colorspace
Bogus JPEG colorspace
Bogus marker length
Wrong JPEG library version: library is %d, caller expects %d
Sampling factors too large for interleaved scan
Invalid memory pool code %d
Unsupported JPEG data precision %d
Invalid progressive parameters Ss=%d Se=%d Ah=%d Al=%d
Invalid progressive parameters at scan script entry %d
Bogus sampling factors
Invalid scan script at entry %d
Improper call to JPEG library in state %d
JPEG parameter struct mismatch: library thinks size is %u, caller expects %u
Bogus virtual array access
Buffer passed to JPEG library is too small
Suspension not allowed here
CCIR601 sampling not implemented yet
Too many color components: %d, max %d
Unsupported color conversion request
Bogus DAC index %d
Bogus DAC value 0x%x
Bogus DHT index %d
Bogus DQT index %d
Empty JPEG image (DNL not supported)
Read from EMS failed
Write to EMS failed
Didn't expect more than one scan
Input file read error
Output file write error --- out of disk space?
Fractional sampling not implemented yet
Huffman code size table overflow
Missing Huffman code table entry
Maximum supported image dimension is %u pixels
Empty input file
Premature end of input file
Cannot transcode due to multiple use of quantization table %d
Scan script does not transmit all data
Invalid color quantization mode change
Not implemented yet
Requested feature was omitted at compile time
Backing store not supported
Huffman table 0x%02x was not defined
JPEG datastream contains no image
Quantization table 0x%02x was not defined
Not a JPEG file: starts with 0x%02x 0x%02x
Insufficient memory (case %d)
Cannot quantize more than %d color components
Cannot quantize to fewer than %d colors
Cannot quantize to more than %d colors
Invalid JPEG file structure: two SOF markers
Invalid JPEG file structure: missing SOS marker
Unsupported JPEG process: SOF type 0x%02x
Invalid JPEG file structure: two SOI markers
Invalid JPEG file structure: SOS before SOF
Failed to create temporary file %s
Read failed on temporary file
Seek failed on temporary file
Write failed on temporary file --- out of disk space?
Application transferred too few scanlines
Unsupported marker type 0x%02x
Virtual array controller messed up
Image too wide for this implementation
Read from XMS failed
Write to XMS failed
Copyright (C) 1998, Thomas G. Lane
6b  27-Mar-1998
Caution: quantization tables are too coarse for baseline JPEG
Adobe APP14 marker: version %d, flags 0x%04x 0x%04x, transform %d
Unknown APP0 marker (not JFIF), length %u
Unknown APP14 marker (not Adobe), length %u
Define Arithmetic Table 0x%02x: 0x%02x
Define Huffman Table 0x%02x
Define Quantization Table %d  precision %d
Define Restart Interval %u
Freed EMS handle %u
Obtained EMS handle %u
End Of Image
        %3d %3d %3d %3d %3d %3d %3d %3d
JFIF APP0 marker: version %d.%02d, density %dx%d  %d
Warning: thumbnail image size does not match data length %u
JFIF extension marker: type 0x%02x, length %u
    with %d x %d thumbnail image
Miscellaneous marker 0x%02x, length %u
Unexpected marker 0x%02x
        %4u %4u %4u %4u %4u %4u %4u %4u
Quantizing to %d = %d*%d*%d colors
Quantizing to %d colors
Selected %d colors for quantization
At marker 0x%02x, recovery action %d
RST%d
Smoothing not supported with nonstandard sampling ratios
Start Of Frame 0x%02x: width=%u, height=%u, components=%d
    Component %d: %dhx%dv q=%d
Start of Image
Start Of Scan: %d components
    Component %d: dc=%d ac=%d
  Ss=%d, Se=%d, Ah=%d, Al=%d
Closed temporary file %s
Opened temporary file %s
JFIF extension marker: JPEG-compressed thumbnail image, length %u
JFIF extension marker: palette thumbnail image, length %u
JFIF extension marker: RGB thumbnail image, length %u
Unrecognized component IDs %d %d %d, assuming YCbCr
Freed XMS handle %u
Obtained XMS handle %u
Unknown Adobe color transform code %d
Inconsistent progression sequence for component %d coefficient %d
Corrupt JPEG data: %u extraneous bytes before marker 0x%02x
Corrupt JPEG data: premature end of data segment
Corrupt JPEG data: bad Huffman code
Warning: unknown JFIF revision number %d.%02d
Premature end of JPEG file
Corrupt JPEG data: found marker 0x%02x instead of RST%d
Invalid SOS parameters for sequential JPEG
Application transferred too many scanlines
JPEGMEM
%ld%c
buffer NULL in CVipImgBase::Allocate()
buffer NULL in LoadFromText()
%10d
\e")081*#
$+29:3,%
&-4;<5.'/6=>7?????????????????
/cccc
Bcccc
8ccccc/Bcccccccccccccccccccccccccccccccccccccc
1H\v\f\r
#@\\\n
%7N_
8@Wb
(3DQgp(:9Wmhyd3<EPgqxg=78>M\\ec
AQ\aaq
\t#3R
&'()*56789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz
Qa\a"q
$3br
%&'()*456789:CDEFGHIJSTUVWXYZcdefghijstuvwxyz
\a\b\t\n\v
\a\b\t\n\v
JFIF
*** Happen NULL in RBaseStream::ReadBlock
\n\n\n\n
 ?\n<\n<
\v\n\t\b\a
\v\n\t\b\a
none
selected
moving
cleaning
cleaned
stopped
failed
spause
None
MasterMapChange
CleaningCompleted
MapCreatingCompleted
silence
IDLE
ARM_INIT
POWER_OFF
CHARGE
STANDBY
PAUSE
CREATING_PAUSE
SELECT_GO_PAUSE
ERROR
TIMER
SET_CLOCK
SET_RESERVE
SET_CANCEL_REASERVE
RESERVE_CLEAN_AUTO
HOMING
DOCKING
LOW_HOMING
AUTO
AUTO_HOMING
AUTO_DOCKING
AUTO_CHARGE
AUTO_END_HOMING
AUTO_END_DOCKING
MAX_RETURN
MAX_HOMING
MAX_DOCKING
MAX_CHARGE
CREATING_MAPSELECT_GO
SELECT_GO_HOMING
SELECT_GO_DOCKING
SELECT_GO_CHARGE
SELECT_GO_END_HOMING
SELECT_GO_END_DOCKING
EXPO
EXPO_RETURN
EXPO_HOMING
EXPO_DOCKING
EXPO_CHARGE
SPOT
MANUAL
POINTCLEANING
SMARTCARE
WILD_DEMO
EASY_SETUP
VIEW_AP
VIEW_VCR
ALLOW_TOKEN
OTN_REBOOT
OTN_UPDATE
OTN_RESULT_SUCCESS
OTN_RESULT_FAIL
ARM_CAM_CALI
ARM_WCAM_CALI
ARM_WF_CAM_CALI
ARM_TRANSMIT_IMAGE
ARM_UPDATE
JIG_PCT
OTN_AGREE
HASS_SMARTCARE
INFO_DEL
NULL
dbg_stream3
dbg_stream2
dbg_stream1
$6GYk}
}kYG6$
xj^SI@92,'"
\f\v\t\b\a
